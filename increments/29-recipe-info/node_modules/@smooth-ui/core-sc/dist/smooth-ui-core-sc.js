(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('prop-types'), require('styled-components'), require('polished'), require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'prop-types', 'styled-components', 'polished', 'react', 'react-dom'], factory) :
  (global = global || self, factory(global.smoothUI = {}, global.PropTypes, global.styled, global.polished, global.React, global.ReactDom));
}(this, function (exports, PropTypes, styled, polished, React, reactDom) { 'use strict';

  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
  var styled__default = 'default' in styled ? styled['default'] : styled;
  var React__default = 'default' in React ? React['default'] : React;
  var reactDom__default = 'default' in reactDom ? reactDom['default'] : reactDom;

  var wrapEvent = function wrapEvent(handler, cb) {
    return function (event) {
      if (handler) {
        handler(event);
      }

      if (!event.defaultPrevented) {
        cb(event);
      }
    };
  };
  var stopPropagation = function stopPropagation(event) {
    return event.stopPropagation();
  };

  var mediaMinWidth = function mediaMinWidth(value) {
    return "@media (min-width: " + value + "px)";
  };
  var mediaMaxWidth = function mediaMaxWidth(value) {
    return "@media (max-width: " + value + "px)";
  };
  var mediaBetweenWidth = function mediaBetweenWidth(min, max) {
    return "@media (min-width: " + min + "px) and (max-width: " + max + "px)";
  };

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  var is = function is(n) {
    return n !== undefined && n !== null;
  };
  var num = function num(n) {
    return typeof n === 'number' && !Number.isNaN(n);
  };
  var func = function func(n) {
    return typeof n === 'function';
  };
  var get = function get(obj) {
    for (var _len = arguments.length, paths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      paths[_key - 1] = arguments[_key];
    }

    return paths.join('.').split('.').reduce(function (a, b) {
      return a && is(a[b]) ? a[b] : undefined;
    }, obj);
  };
  var cascade = function cascade(fn) {
    if (!func(fn)) return fn;

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    var next = fn.apply(void 0, args);
    return cascade.apply(void 0, [next].concat(args));
  };
  var omit = function omit(obj, fields) {
    var shallowCopy = _objectSpread({}, obj);

    for (var i = 0; i < fields.length; i += 1) {
      var key = fields[i];
      delete shallowCopy[key];
    }

    return shallowCopy;
  };

  var getTheme = function getTheme(_ref) {
    var _ref$theme = _ref.theme,
        theme = _ref$theme === void 0 ? {} : _ref$theme;
    return theme;
  };
  var thd = function thd(name, defaultValue, transform) {
    var getFromProps = function getFromProps(p) {
      var value = cascade(function (p) {
        return get(getTheme(p), name);
      }, p);

      if (value === undefined) {
        return cascade(defaultValue, p);
      }

      if (transform) {
        return transform(value);
      }

      return value;
    };

    getFromProps.default = defaultValue;
    return getFromProps;
  };
  var th = function th(name, transform) {
    return function (p) {
      var value = cascade(function (p) {
        return get(getTheme(p), name);
      }, p);

      if (!is(value)) {
        throw new Error(name + " not found in theme");
      }

      if (transform) {
        return transform(value);
      }

      return value;
    };
  };
  var mixin = function mixin(name, defaultFn) {
    var mixinFn = function mixinFn() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return function (p) {
        var fn = get(getTheme(p), name) || defaultFn;
        return fn.apply(void 0, args)(p);
      };
    };

    mixinFn.default = defaultFn;
    return mixinFn;
  };
  function definitionsToTheme(values) {
    var theme = {};
    var themingKeys = Object.keys(values);

    for (var i = 0; i < themingKeys.length; i++) {
      var key = themingKeys[i];
      var value = values[key];
      theme[key] = value && value.default !== undefined ? value.default : value;
    }

    return theme;
  }

  var unit = function unit(_unit) {
    return function (value) {
      return num(value) ? "" + value + _unit : value;
    };
  };
  var px =
  /*#__PURE__*/
  unit('px');
  var calc = function calc(value, fn) {
    var _String$match = String(value).match(/([\d.]+)\s*(.*)/),
        num$$1 = _String$match[1],
        unit = _String$match[2];

    return "" + fn(Number(num$$1)) + (unit || 'px');
  };

  var black =
  /*#__PURE__*/
  thd('black', '#000');
  var white =
  /*#__PURE__*/
  thd('white', '#fff');
  var gray100 =
  /*#__PURE__*/
  thd('gray100', '#f8f9fa');
  var gray200 =
  /*#__PURE__*/
  thd('gray200', '#e9ecef');
  var gray300 =
  /*#__PURE__*/
  thd('gray300', '#dee2e6');
  var gray400 =
  /*#__PURE__*/
  thd('gray400', '#ced4da');
  var gray500 =
  /*#__PURE__*/
  thd('gray500', '#adb5bd');
  var gray600 =
  /*#__PURE__*/
  thd('gray600', '#6c757d');
  var gray700 =
  /*#__PURE__*/
  thd('gray700', '#495057');
  var gray800 =
  /*#__PURE__*/
  thd('gray800', '#343a40');
  var gray900 =
  /*#__PURE__*/
  thd('gray900', '#212529');
  var blue =
  /*#__PURE__*/
  thd('blue', '#007bff');
  var indigo =
  /*#__PURE__*/
  thd('indigo', '#6610f2');
  var purple =
  /*#__PURE__*/
  thd('purple', '#6f42c1');
  var pink =
  /*#__PURE__*/
  thd('pink', '#e83e8c');
  var red =
  /*#__PURE__*/
  thd('red', '#dc3545');
  var brick =
  /*#__PURE__*/
  thd('brick', '#bd4932');
  var orange =
  /*#__PURE__*/
  thd('orange', '#fd7e14');
  var yellow =
  /*#__PURE__*/
  thd('yellow', '#ffc107');
  var green =
  /*#__PURE__*/
  thd('green', '#28a745');
  var teal =
  /*#__PURE__*/
  thd('teal', '#20c997');
  var cyan =
  /*#__PURE__*/
  thd('cyan', '#17a2b8');
  var primary =
  /*#__PURE__*/
  thd('primary', brick);
  var secondary =
  /*#__PURE__*/
  thd('secondary', gray600);
  var success =
  /*#__PURE__*/
  thd('success', green);
  var info =
  /*#__PURE__*/
  thd('info', cyan);
  var warning =
  /*#__PURE__*/
  thd('warning', yellow);
  var danger =
  /*#__PURE__*/
  thd('danger', red);
  var light =
  /*#__PURE__*/
  thd('light', gray100);
  var dark =
  /*#__PURE__*/
  thd('dark', gray800);
  var primaryLight =
  /*#__PURE__*/
  thd('primaryLight', function (p) {
    return polished.lighten(0.3, primary(p));
  });
  var secondaryLight =
  /*#__PURE__*/
  thd('secondaryLight', function (p) {
    return polished.lighten(0.3, secondary(p));
  });
  var colorVariants =
  /*#__PURE__*/
  thd('colorVariants', ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark']);
  var colors =
  /*#__PURE__*/
  thd('colors', {
    black: black,
    white: white,
    gray100: gray100,
    gray200: gray200,
    gray300: gray300,
    gray400: gray400,
    gray500: gray500,
    gray600: gray600,
    gray700: gray700,
    gray800: gray800,
    gray900: gray900,
    blue: blue,
    indigo: indigo,
    purple: purple,
    pink: pink,
    red: red,
    brick: brick,
    orange: orange,
    yellow: yellow,
    green: green,
    teal: teal,
    cyan: cyan,
    primary: primary,
    secondary: secondary,
    success: success,
    info: info,
    warning: warning,
    danger: danger,
    light: light,
    dark: dark
  });
  var colorInterval =
  /*#__PURE__*/
  thd('colorInterval', 0.08);
  var colorVariant =
  /*#__PURE__*/
  mixin('colorVariant', function (variant) {
    return function (p) {
      var thValue = thd(variant)(p);
      if (thValue) return thValue;
      var colorValue = colors(p)[variant];
      if (colorValue) return colorValue(p);
      return variant;
    };
  });
  var colorLevel =
  /*#__PURE__*/
  mixin('colorLevel', function (color, level) {
    return function (p) {
      var baseColor = level > 0 ? black(p) : white(p);
      var absLevel = Math.abs(level);
      return polished.mix(absLevel * colorInterval(p), baseColor, color);
    };
  });
  var yiqContrastedThreshold =
  /*#__PURE__*/
  thd('yiqContrastedThreshold', 150);
  var yikTextDark =
  /*#__PURE__*/
  thd('yikTextDark', '#111');
  var yikTextLight =
  /*#__PURE__*/
  thd('yikTextLight', '#fff');
  var colorYik =
  /*#__PURE__*/
  mixin('colorYik', function (color) {
    return function (p) {
      var _parseToRgb = polished.parseToRgb(color),
          r = _parseToRgb.red,
          g = _parseToRgb.green,
          b = _parseToRgb.blue;

      var yik = (r * 299 + g * 587 + b * 114) / 1000;
      return yik >= yiqContrastedThreshold(p) ? yikTextDark(p) : yikTextLight(p);
    };
  });

  var alertPaddingY =
  /*#__PURE__*/
  thd('alertPaddingY', '.75rem');
  var alertPaddingX =
  /*#__PURE__*/
  thd('alertPaddingX', '1.25rem');
  var alertMarginBottom =
  /*#__PURE__*/
  thd('alertMarginBottom', '1rem');
  var alertColorLevel =
  /*#__PURE__*/
  thd('alertColorLevel', 6);
  var alertBgLevel =
  /*#__PURE__*/
  thd('alertBgLevel', -10);
  var alertBorderLevel =
  /*#__PURE__*/
  thd('alertBorderLevel', -9);
  var alertVariant =
  /*#__PURE__*/
  mixin('alertVariant', function (variant) {
    return function (p) {
      var variantColor = colorVariant(variant)(p);
      var color = colorLevel(variantColor, alertColorLevel(p))(p);
      var bgColor = colorLevel(variantColor, alertBgLevel(p))(p);
      var borderColor = colorLevel(variantColor, alertBorderLevel(p))(p);
      var hrColor = polished.darken(0.05, color);
      return styled.css(["color:", ";background-color:", ";border-color:", ";hr{border-top-color:", ";}"], color, bgColor, borderColor, hrColor);
    };
  });

  var borderRadius =
  /*#__PURE__*/
  thd('borderRadius', '.25rem');
  var borderRadiusSm =
  /*#__PURE__*/
  thd('borderRadiusSm', '.2rem');
  var borderRadiusLg =
  /*#__PURE__*/
  thd('borderRadiusLg', '.3rem');
  var borderWidth =
  /*#__PURE__*/
  thd('borderWidth', '1px');

  var baseFocus =
  /*#__PURE__*/
  mixin('baseFocus', function (color) {
    return function () {
      return styled.css(["outline:0;border-color:", ";box-shadow:0 0 2px ", ";"], polished.lighten(0.25, color), polished.transparentize(0.1, color));
    };
  });
  var controlFocus =
  /*#__PURE__*/
  mixin('controlFocus', function (color) {
    return function () {
      return styled.css(["box-shadow:0 0 0 0.2rem ", ";"], polished.transparentize(0.75, color));
    };
  });

  var fontSizes =
  /*#__PURE__*/
  thd('fontSizes', [12, 14, 16, 20, 24, 32, 48, 64, 72]);
  var fontFamily =
  /*#__PURE__*/
  thd('fontFamily', '-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif');
  var fontSizeBase =
  /*#__PURE__*/
  thd('fontSizeBase', '1rem');
  var fontSizeSm =
  /*#__PURE__*/
  thd('fontSizeSm', '1rem', function (s) {
    return polished.modularScale(-1, s);
  });
  var fontSizeLg =
  /*#__PURE__*/
  thd('fontSizeLg', '1rem', function (s) {
    return polished.modularScale(1, s);
  });
  var fontWeightLight =
  /*#__PURE__*/
  thd('fontWeightLight', 300);
  var fontWeightNormal =
  /*#__PURE__*/
  thd('fontWeightNormal', 400);
  var fontWeightBold =
  /*#__PURE__*/
  thd('fontWeightBold', 700);
  var lineHeightBase =
  /*#__PURE__*/
  thd('lineHeightBase', 1.5);
  var lineHeightSm =
  /*#__PURE__*/
  thd('lineHeightSm', 1.5);
  var lineHeightLg =
  /*#__PURE__*/
  thd('lineHeightLg', 1.5);

  var inputBtnPaddingY =
  /*#__PURE__*/
  thd('inputBtnPaddingY', '.375rem');
  var inputBtnPaddingX =
  /*#__PURE__*/
  thd('inputBtnPaddingX', '.75rem');
  var inputBtnLineHeight =
  /*#__PURE__*/
  thd('inputBtnLineHeight', lineHeightBase);
  var inputBtnPaddingYSm =
  /*#__PURE__*/
  thd('inputBtnPaddingYSm', '.25rem');
  var inputBtnPaddingXSm =
  /*#__PURE__*/
  thd('inputBtnPaddingXSm', '.5rem');
  var inputBtnLineHeightSm =
  /*#__PURE__*/
  thd('inputBtnLineHeightSm', lineHeightSm);
  var inputBtnPaddingYLg =
  /*#__PURE__*/
  thd('inputBtnPaddingYLg', '.5rem');
  var inputBtnPaddingXLg =
  /*#__PURE__*/
  thd('inputBtnPaddingXLg', '1rem');
  var inputBtnLineHeightLg =
  /*#__PURE__*/
  thd('inputBtnLineHeightLg', lineHeightLg);
  var inputPaddingY =
  /*#__PURE__*/
  thd('inputPaddingY', inputBtnPaddingY);
  var inputPaddingX =
  /*#__PURE__*/
  thd('inputPaddingX', inputBtnPaddingX);
  var inputLineHeight =
  /*#__PURE__*/
  thd('inputLineHeight', inputBtnLineHeight);
  var inputPaddingYSm =
  /*#__PURE__*/
  thd('inputPaddingYSm', inputBtnPaddingYSm);
  var inputPaddingXSm =
  /*#__PURE__*/
  thd('inputPaddingXSm', inputBtnPaddingXSm);
  var inputLineHeightSm =
  /*#__PURE__*/
  thd('inputLineHeightSm', inputBtnLineHeightSm);
  var inputPaddingYLg =
  /*#__PURE__*/
  thd('inputPaddingYLg', inputBtnPaddingYLg);
  var inputPaddingXLg =
  /*#__PURE__*/
  thd('inputPaddingXLg', inputBtnPaddingXLg);
  var inputLineHeightLg =
  /*#__PURE__*/
  thd('inputLineHeightLg', inputBtnLineHeightLg);
  var inputBorderWidth =
  /*#__PURE__*/
  thd('inputBorderWidth', borderWidth);
  var inputBorderColor =
  /*#__PURE__*/
  thd('inputBorderColor', gray300);
  var inputBgColor =
  /*#__PURE__*/
  thd('inputBgColor', white);
  var inputDisabledBgColor =
  /*#__PURE__*/
  thd('inputDisabledBgColor', gray100);
  var inputDisabledText =
  /*#__PURE__*/
  thd('inputDisabledText', gray600);
  var inputPlaceholderText =
  /*#__PURE__*/
  thd('inputPlaceholderText', gray600);
  var inputTextColor =
  /*#__PURE__*/
  thd('inputTextColor', gray900);

  var btnPaddingY =
  /*#__PURE__*/
  thd('btnPaddingY', inputBtnPaddingY);
  var btnPaddingX =
  /*#__PURE__*/
  thd('btnPaddingX', inputBtnPaddingX);
  var btnLineHeight =
  /*#__PURE__*/
  thd('btnLineHeight', inputBtnLineHeight);
  var btnPaddingYSm =
  /*#__PURE__*/
  thd('btnPaddingYSm', inputBtnPaddingYSm);
  var btnPaddingXSm =
  /*#__PURE__*/
  thd('btnPaddingXSm', inputBtnPaddingXSm);
  var btnLineHeightSm =
  /*#__PURE__*/
  thd('btnLineHeightSm', inputBtnLineHeightSm);
  var btnPaddingYLg =
  /*#__PURE__*/
  thd('btnPaddingYLg', inputBtnPaddingYLg);
  var btnPaddingXLg =
  /*#__PURE__*/
  thd('btnPaddingXLg', inputBtnPaddingXLg);
  var btnLineHeightLg =
  /*#__PURE__*/
  thd('btnLineHeightLg', inputBtnLineHeightLg);
  var btnBorderWidth =
  /*#__PURE__*/
  thd('btnBorderWidth', 0);
  var btnDisabledOpacity =
  /*#__PURE__*/
  thd('btnDisabledOpacity', 0.8);
  var btnVariant =
  /*#__PURE__*/
  mixin('btnVariant', function (variant) {
    return function (p) {
      var color = colorVariant(variant)(p);
      return styled.css(["color:", ";background-color:", ";&:focus{", ";}&:not(:disabled):hover,&:not(:disabled):active{background-color:", ";}"], colorYik(color)(p), color, baseFocus(color)(p), polished.darken(0.05, color));
    };
  });

  var gridColumns =
  /*#__PURE__*/
  thd('gridColumns', 12);
  var gridGutter =
  /*#__PURE__*/
  thd('gridGutter', 8);
  var gridMaxWidths =
  /*#__PURE__*/
  thd('gridMaxWidths', {
    sm: '540px',
    md: '720px',
    lg: '960px',
    xl: '1140px'
  });

  var headingsMarginBottom =
  /*#__PURE__*/
  thd('headingsMarginBottom', '.5rem');
  var headingsFontFamily =
  /*#__PURE__*/
  thd('headingsFontFamily', fontFamily);
  var headingsFontWeight =
  /*#__PURE__*/
  thd('headingsFontWeight', 500);
  var headingsLineHeight =
  /*#__PURE__*/
  thd('headingsLineHeight', 1.2);
  var headingsColor =
  /*#__PURE__*/
  thd('headingsColor', 'inherit');
  var h1FontSize =
  /*#__PURE__*/
  thd('h1FontSize', '2.5rem');
  var h2FontSize =
  /*#__PURE__*/
  thd('h2FontSize', '2rem');
  var h3FontSize =
  /*#__PURE__*/
  thd('h3FontSize', '1.75rem');
  var h4FontSize =
  /*#__PURE__*/
  thd('h4FontSize', '1.5rem');
  var h5FontSize =
  /*#__PURE__*/
  thd('h5FontSize', '1.25rem');
  var h6FontSize =
  /*#__PURE__*/
  thd('h6FontSize', '1rem');
  var display1Size =
  /*#__PURE__*/
  thd('display1Size', '6rem');
  var display2Size =
  /*#__PURE__*/
  thd('display2Size', '5.5rem');
  var display3Size =
  /*#__PURE__*/
  thd('display3Size', '4.4rem');
  var display4Size =
  /*#__PURE__*/
  thd('display4Size', '3.5rem');
  var display1Weight =
  /*#__PURE__*/
  thd('display1Weight', 300);
  var display2Weight =
  /*#__PURE__*/
  thd('display2Weight', 300);
  var display3Weight =
  /*#__PURE__*/
  thd('display3Weight', 300);
  var display4Weight =
  /*#__PURE__*/
  thd('display4Weight', 300);
  var displayLineHeight =
  /*#__PURE__*/
  thd('displayLineHeight', headingsLineHeight);

  var modalBackdropBg =
  /*#__PURE__*/
  thd('modalBackdropBg', 'rgba(0, 0, 0, 0.5)');
  var modalTransitionDuration =
  /*#__PURE__*/
  thd('modalTransitionDuration', 300);
  var modalInnerPadding =
  /*#__PURE__*/
  thd('modalInnerPadding', '1rem');
  var modalDialogMargin =
  /*#__PURE__*/
  thd('modalDialogMargin', '0.5rem');
  var modalDialogMarginYSmUp =
  /*#__PURE__*/
  thd('modalDialogMarginYSmUp', '1.75rem');
  var modalContentBg =
  /*#__PURE__*/
  thd('modalContentBg', white);
  var modalContentBorderWidth =
  /*#__PURE__*/
  thd('modalContentBorderWidth', borderWidth);
  var modalContentBorderColor =
  /*#__PURE__*/
  thd('modalContentBorderColor', black, function (color) {
    return polished.transparentize(0.8, color);
  });
  var modalContentBorderRadius =
  /*#__PURE__*/
  thd('modalContentBorderRadius', borderRadiusLg);
  var modalContentBoxShadowXs =
  /*#__PURE__*/
  thd('modalContentBoxShadowXs', function (p) {
    return styled.css(["box-shadow:0 0.25rem 0.5rem ", ";"], polished.transparentize(0.8, black(p)));
  });
  var modalContentBoxShadowSmUp =
  /*#__PURE__*/
  thd('modalContentBoxShadowSmUp', function (p) {
    return styled.css(["box-shadow:0 0.5rem 1rem ", ";"], polished.transparentize(0.8, black(p)));
  });
  var modalHeaderBorderColor =
  /*#__PURE__*/
  thd('modalHeaderBorderColor', gray200);
  var modalFooterBorderColor =
  /*#__PURE__*/
  thd('modalFooterBorderColor', modalHeaderBorderColor);
  var modalHeaderBorderWidth =
  /*#__PURE__*/
  thd('modalHeaderBorderWidth', modalContentBorderWidth);
  var modalFooterBorderWidth =
  /*#__PURE__*/
  thd('modalFooterBorderWidth', modalHeaderBorderWidth);

  var breakpoints =
  /*#__PURE__*/
  thd('breakpoints', {
    xs: 0,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200
  });

  var getBreakpointsEntries = function getBreakpointsEntries(p) {
    var bks = breakpoints(p);
    var entries = Object.keys(bks).reduce(function (entries, key) {
      return [].concat(entries, [[key, bks[key]]]);
    }, []);
    return entries.sort(function (a, b) {
      return a[1] > b[1];
    });
  };

  var getNextBreakpoint = function getNextBreakpoint(name, p) {
    var entries = getBreakpointsEntries(p);
    var index = entries.findIndex(function (_ref) {
      var key = _ref[0];
      return key === name;
    });
    return index < entries.length - 1 ? entries[index + 1][0] : null;
  };

  var getPreviousBreakpoint = function getPreviousBreakpoint(name, p) {
    var entries = getBreakpointsEntries(p);
    var index = entries.findIndex(function (_ref2) {
      var key = _ref2[0];
      return key === name;
    });
    return index >= 1 ? entries[index - 1][0] : null;
  };
  /**
   * Minimum breakpoint width.
   * Null for the smallest breakpoint.
   */


  var getBreakpointMin = function getBreakpointMin(name, p) {
    var bks = breakpoints(p);
    var breakPoint = bks[name];
    return breakPoint !== 0 ? breakPoint : null;
  };
  /**
   * Maximum breakpoint width. Null for the largest (last) breakpoint.
   * The maximum value is calculated as the minimum of the next one less 0.02px
   * to work around the limitations of `min-` and `max-` prefixes and viewports with fractional widths.
   * See https://www.w3.org/TR/mediaqueries-4/#mq-min-max
   * Uses 0.02px rather than 0.01px to work around a current rounding bug in Safari.
   * See https://bugs.webkit.org/show_bug.cgi?id=178261
   */


  var getBreakpointMax = function getBreakpointMax(name, p) {
    var next = getNextBreakpoint(name, p);
    return next ? getBreakpointMin(next, p) - 0.02 : null;
  };

  var up =
  /*#__PURE__*/
  mixin('up', function (name, code) {
    return function (p) {
      var value = getBreakpointMin(name, p);
      if (value === null) return code;
      return styled.css(["", "{", ";}"], mediaMinWidth(value), code);
    };
  });
  var down =
  /*#__PURE__*/
  mixin('down', function (name, code) {
    return function (p) {
      var next = getNextBreakpoint(name, p);
      var previous = getPreviousBreakpoint(name, p);
      var value = getBreakpointMax(previous, p);
      if (next === null) return code;
      return styled.css(["", "{", ";}"], mediaMaxWidth(value), code);
    };
  });
  var between =
  /*#__PURE__*/
  mixin('between', function (lower, upper, code) {
    return function (p) {
      var min = getBreakpointMin(lower, p);
      var max = getBreakpointMax(upper, p);
      var upperPrevious = getPreviousBreakpoint(upper, p);
      var previousMax = getBreakpointMax(upperPrevious, p);

      if (min !== null && max !== null) {
        return styled.css(["", "{", ";}"], mediaBetweenWidth(min, previousMax), code);
      }

      if (max === null) return up(lower, code)(p);
      if (min === null) return down(upper, code)(p);
      return null;
    };
  });

  var spaces =
  /*#__PURE__*/
  thd('spaces', [0, 8, 16, 24, 32, 40, 48, 56, 64, 72]);

  var safeTransitionAttrs = ['color', 'border-style', 'border-color', 'visibility', 'background', 'background-color', 'text-decoration', 'box-shadow', 'transform', 'opacity'];
  var transitionEnabled =
  /*#__PURE__*/
  thd('transitionEnabled', true);
  var transitionDuration =
  /*#__PURE__*/
  thd('transitionDuration', '.2s');
  var transitionEasingFunc =
  /*#__PURE__*/
  thd('transitionEasingFunc', 'ease-in-out');
  var transition =
  /*#__PURE__*/
  mixin('transition', function (value) {
    return function (p) {
      if (!transitionEnabled(p)) return null;
      return styled.css(["transition:", ";@media screen and (prefers-reduced-motion:reduce){transition:none;}"], value);
    };
  });
  var transitionBase =
  /*#__PURE__*/
  thd('transitionBase', function (p) {
    return transition(safeTransitionAttrs.map(function (attr) {
      return attr + " " + transitionDuration(p) + " " + transitionEasingFunc(p);
    }).join(','))(p);
  });

  var zIndexControl =
  /*#__PURE__*/
  thd('zIndexControl', 1);
  var zIndexInnerSwitch =
  /*#__PURE__*/
  thd('zIndexInnerSwitch', 10);
  var zIndexModal =
  /*#__PURE__*/
  thd('zIndexModal', 1050);
  var zIndexModalBackdrop =
  /*#__PURE__*/
  thd('zIndexModalBackdrop', 1071);



  var theming = /*#__PURE__*/Object.freeze({
    alertPaddingY: alertPaddingY,
    alertPaddingX: alertPaddingX,
    alertMarginBottom: alertMarginBottom,
    alertColorLevel: alertColorLevel,
    alertBgLevel: alertBgLevel,
    alertBorderLevel: alertBorderLevel,
    alertVariant: alertVariant,
    borderRadius: borderRadius,
    borderRadiusSm: borderRadiusSm,
    borderRadiusLg: borderRadiusLg,
    borderWidth: borderWidth,
    btnPaddingY: btnPaddingY,
    btnPaddingX: btnPaddingX,
    btnLineHeight: btnLineHeight,
    btnPaddingYSm: btnPaddingYSm,
    btnPaddingXSm: btnPaddingXSm,
    btnLineHeightSm: btnLineHeightSm,
    btnPaddingYLg: btnPaddingYLg,
    btnPaddingXLg: btnPaddingXLg,
    btnLineHeightLg: btnLineHeightLg,
    btnBorderWidth: btnBorderWidth,
    btnDisabledOpacity: btnDisabledOpacity,
    btnVariant: btnVariant,
    black: black,
    white: white,
    gray100: gray100,
    gray200: gray200,
    gray300: gray300,
    gray400: gray400,
    gray500: gray500,
    gray600: gray600,
    gray700: gray700,
    gray800: gray800,
    gray900: gray900,
    blue: blue,
    indigo: indigo,
    purple: purple,
    pink: pink,
    red: red,
    brick: brick,
    orange: orange,
    yellow: yellow,
    green: green,
    teal: teal,
    cyan: cyan,
    primary: primary,
    secondary: secondary,
    success: success,
    info: info,
    warning: warning,
    danger: danger,
    light: light,
    dark: dark,
    primaryLight: primaryLight,
    secondaryLight: secondaryLight,
    colorVariants: colorVariants,
    colors: colors,
    colorInterval: colorInterval,
    colorVariant: colorVariant,
    colorLevel: colorLevel,
    yiqContrastedThreshold: yiqContrastedThreshold,
    yikTextDark: yikTextDark,
    yikTextLight: yikTextLight,
    colorYik: colorYik,
    baseFocus: baseFocus,
    controlFocus: controlFocus,
    gridColumns: gridColumns,
    gridGutter: gridGutter,
    gridMaxWidths: gridMaxWidths,
    headingsMarginBottom: headingsMarginBottom,
    headingsFontFamily: headingsFontFamily,
    headingsFontWeight: headingsFontWeight,
    headingsLineHeight: headingsLineHeight,
    headingsColor: headingsColor,
    h1FontSize: h1FontSize,
    h2FontSize: h2FontSize,
    h3FontSize: h3FontSize,
    h4FontSize: h4FontSize,
    h5FontSize: h5FontSize,
    h6FontSize: h6FontSize,
    display1Size: display1Size,
    display2Size: display2Size,
    display3Size: display3Size,
    display4Size: display4Size,
    display1Weight: display1Weight,
    display2Weight: display2Weight,
    display3Weight: display3Weight,
    display4Weight: display4Weight,
    displayLineHeight: displayLineHeight,
    inputBtnPaddingY: inputBtnPaddingY,
    inputBtnPaddingX: inputBtnPaddingX,
    inputBtnLineHeight: inputBtnLineHeight,
    inputBtnPaddingYSm: inputBtnPaddingYSm,
    inputBtnPaddingXSm: inputBtnPaddingXSm,
    inputBtnLineHeightSm: inputBtnLineHeightSm,
    inputBtnPaddingYLg: inputBtnPaddingYLg,
    inputBtnPaddingXLg: inputBtnPaddingXLg,
    inputBtnLineHeightLg: inputBtnLineHeightLg,
    inputPaddingY: inputPaddingY,
    inputPaddingX: inputPaddingX,
    inputLineHeight: inputLineHeight,
    inputPaddingYSm: inputPaddingYSm,
    inputPaddingXSm: inputPaddingXSm,
    inputLineHeightSm: inputLineHeightSm,
    inputPaddingYLg: inputPaddingYLg,
    inputPaddingXLg: inputPaddingXLg,
    inputLineHeightLg: inputLineHeightLg,
    inputBorderWidth: inputBorderWidth,
    inputBorderColor: inputBorderColor,
    inputBgColor: inputBgColor,
    inputDisabledBgColor: inputDisabledBgColor,
    inputDisabledText: inputDisabledText,
    inputPlaceholderText: inputPlaceholderText,
    inputTextColor: inputTextColor,
    modalBackdropBg: modalBackdropBg,
    modalTransitionDuration: modalTransitionDuration,
    modalInnerPadding: modalInnerPadding,
    modalDialogMargin: modalDialogMargin,
    modalDialogMarginYSmUp: modalDialogMarginYSmUp,
    modalContentBg: modalContentBg,
    modalContentBorderWidth: modalContentBorderWidth,
    modalContentBorderColor: modalContentBorderColor,
    modalContentBorderRadius: modalContentBorderRadius,
    modalContentBoxShadowXs: modalContentBoxShadowXs,
    modalContentBoxShadowSmUp: modalContentBoxShadowSmUp,
    modalHeaderBorderColor: modalHeaderBorderColor,
    modalFooterBorderColor: modalFooterBorderColor,
    modalHeaderBorderWidth: modalHeaderBorderWidth,
    modalFooterBorderWidth: modalFooterBorderWidth,
    breakpoints: breakpoints,
    up: up,
    down: down,
    between: between,
    spaces: spaces,
    transitionEnabled: transitionEnabled,
    transitionDuration: transitionDuration,
    transitionEasingFunc: transitionEasingFunc,
    transition: transition,
    transitionBase: transitionBase,
    fontSizes: fontSizes,
    fontFamily: fontFamily,
    fontSizeBase: fontSizeBase,
    fontSizeSm: fontSizeSm,
    fontSizeLg: fontSizeLg,
    fontWeightLight: fontWeightLight,
    fontWeightNormal: fontWeightNormal,
    fontWeightBold: fontWeightBold,
    lineHeightBase: lineHeightBase,
    lineHeightSm: lineHeightSm,
    lineHeightLg: lineHeightLg,
    zIndexControl: zIndexControl,
    zIndexInnerSwitch: zIndexInnerSwitch,
    zIndexModal: zIndexModal,
    zIndexModalBackdrop: zIndexModalBackdrop
  });

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var umd = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    module.exports =
    /*#__PURE__*/
    factory();
  })(commonjsGlobal, function () {

    var isMergeableObject = function isMergeableObject(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };

    function isNonNullObject(value) {
      return !!value && typeof value === 'object';
    }

    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
    } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }

    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }

    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function (element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }

    function mergeObject(target, source, options) {
      var destination = {};

      if (options.isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }

      Object.keys(source).forEach(function (key) {
        if (!options.isMergeableObject(source[key]) || !target[key]) {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        } else {
          destination[key] = deepmerge(target[key], source[key], options);
        }
      });
      return destination;
    }

    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }

    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error('first argument should be an array');
      }

      return array.reduce(function (prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };

    var deepmerge_1 = deepmerge;
    return deepmerge_1;
  });
  });

  var minBreakpoint = function minBreakpoint(breakpoint) {
    return breakpoint !== 0 ? breakpoint : null;
  };

  var minWidth = function minWidth(value) {
    return "@media (min-width: " + value + "px)";
  };

  var DEFAULT_BREAKPOINTS = {
    xs: 0,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200
  };

  var is$1 = function is(n) {
    return n !== undefined && n !== null;
  };

  var num$1 = function num(n) {
    return typeof n === 'number' && !Number.isNaN(n);
  };

  var string = function string(n) {
    return typeof n === 'string' && n !== '';
  };

  var obj = function obj(n) {
    return typeof n === 'object' && n !== null;
  };

  var func$1 = function func(n) {
    return typeof n === 'function';
  };

  var negative = function negative(n) {
    return n < 0;
  };

  var get$1 = function get(obj, path) {
    return String(path).split('.').reduce(function (a, b) {
      return a && is$1(a[b]) ? a[b] : undefined;
    }, obj);
  };

  function merge(acc, item) {
    if (!item) {
      return acc;
    }

    return umd(acc, item, {
      clone: false // No need to clone deep, it's way faster.

    });
  }

  function callOrReturn(fn, arg) {
    if (!func$1(fn)) return fn;
    var next = fn(arg);
    return callOrReturn(next, arg);
  }

  function getThemeValue(theme, path, initial) {
    if (!theme) return undefined;
    return callOrReturn(get$1(initial || theme, path), {
      theme: theme
    });
  }

  function getValue(value, variants, theme) {
    if (is$1(variants)) {
      var valueFromVariants = getThemeValue(theme, value, variants);

      if (is$1(valueFromVariants)) {
        return valueFromVariants;
      }
    }

    return value;
  }

  function styleFromValue(cssProperties, value, theme, themeKey, transform) {
    var variants = getThemeValue(theme, themeKey);
    var computedValue = getValue(value, variants, theme);

    if (string(computedValue) || num$1(computedValue)) {
      var _style = {};

      for (var i = 0; i < cssProperties.length; i++) {
        _style[cssProperties[i]] = transform ? transform(computedValue, {
          rawValue: value,
          variants: variants
        }) : computedValue;
      }

      return _style;
    }

    return null;
  }

  function getThemeFromCssArg(propsOrTheme) {
    if (!propsOrTheme) {
      return null;
    } // Styled Components


    if (propsOrTheme.theme) {
      return propsOrTheme.theme;
    } // Emotion


    return propsOrTheme;
  }

  function getBreakpoints(theme) {
    var themeBreakpoints = getThemeValue(theme, 'breakpoints');

    if (is$1(themeBreakpoints)) {
      return themeBreakpoints;
    }

    return DEFAULT_BREAKPOINTS;
  }

  function createStyleGenerator(getStyle, props, generators) {
    var getStyles = function getStyles(attrs) {
      return function (propsOrTheme) {
        var theme = getThemeFromCssArg(propsOrTheme);
        return getStyle(attrs, theme, propsOrTheme);
      };
    };

    var getStylesFromProps = function getStylesFromProps(props) {
      var theme = props.theme || null;
      return getStyle(props, theme, props);
    };

    getStyles.meta = {
      props: props,
      getStyle: getStyle,
      generators: generators
    };
    getStyles.props = getStylesFromProps;
    return getStyles;
  }

  function styleFromBreakPoint(cssProperties, value, theme, themeKey, transform) {
    var breakpoints = getBreakpoints(theme);
    var keys = Object.keys(value);
    var allStyle = {};

    for (var i = 0; i < keys.length; i++) {
      var breakpoint = keys[i];

      var _style2 = styleFromValue(cssProperties, value[breakpoint], theme, themeKey, transform);

      if (_style2 !== null) {
        var breakpointValue = minBreakpoint(breakpoints[breakpoint]);

        if (breakpointValue === null) {
          allStyle = merge(allStyle, _style2);
        } else {
          var _merge;

          allStyle = merge(allStyle, (_merge = {}, _merge[minWidth(breakpointValue)] = _style2, _merge));
        }
      }
    }

    return allStyle;
  }

  function style(_ref) {
    var prop = _ref.prop,
        cssProperties = _ref.cssProperties,
        _ref$themeKey = _ref.themeKey,
        themeKey = _ref$themeKey === void 0 ? null : _ref$themeKey,
        _ref$transform = _ref.transform,
        transform = _ref$transform === void 0 ? null : _ref$transform;

    function getStyle(attrs, theme) {
      var value = attrs[prop];
      if (!is$1(value)) return null;
      cssProperties = cssProperties || [prop];
      var style = styleFromValue(cssProperties, value, theme, themeKey, transform);

      if (style !== null) {
        return style;
      }

      if (obj(value)) {
        return styleFromBreakPoint(cssProperties, value, theme, themeKey, transform);
      }

      return null;
    }

    return createStyleGenerator(getStyle, [prop]);
  }

  function indexGeneratorsByProp(styles) {
    var index = {};

    for (var i = 0; i < styles.length; i++) {
      var _style3 = styles[i];

      if (_style3 && _style3.meta) {
        var propsKeys = Object.keys(_style3.meta.props);

        for (var j = 0; j < propsKeys.length; j++) {
          var prop = _style3.meta.props[propsKeys[j]];
          index[prop] = _style3;
        }
      }
    }

    return index;
  }

  function compose() {
    var flatGenerators = [];

    for (var _len = arguments.length, generators = new Array(_len), _key = 0; _key < _len; _key++) {
      generators[_key] = arguments[_key];
    }

    generators.forEach(function (gen) {
      if (gen.meta.generators) {
        flatGenerators = [].concat(flatGenerators, gen.meta.generators);
      } else {
        flatGenerators.push(gen);
      }
    });
    var generatorsByProp = indexGeneratorsByProp(flatGenerators);

    function getStyle(attrs, theme) {
      var propKeys = Object.keys(attrs);
      var propCount = propKeys.length;
      var allStyle = {};

      for (var i = 0; i < propCount; i++) {
        var propKey = propKeys[i];
        var generator = generatorsByProp[propKey];

        if (generator) {
          allStyle = merge(allStyle, generator.meta.getStyle(attrs, theme));
        }
      }

      return allStyle;
    }

    var props = flatGenerators.reduce(function (keys, generator) {
      return [].concat(keys, generator.meta.props);
    }, []);
    return createStyleGenerator(getStyle, props, generators);
  }

  var background =
  /*#__PURE__*/
  style({
    prop: 'background'
  });
  var backgroundColor =
  /*#__PURE__*/
  style({
    prop: 'backgroundColor',
    themeKey: 'colors'
  });
  var backgroundImage =
  /*#__PURE__*/
  style({
    prop: 'backgroundImage'
  });
  var backgroundSize =
  /*#__PURE__*/
  style({
    prop: 'backgroundSize'
  });
  var backgroundPosition =
  /*#__PURE__*/
  style({
    prop: 'backgroundPosition'
  });
  var backgroundRepeat =
  /*#__PURE__*/
  style({
    prop: 'backgroundRepeat'
  });
  var backgrounds =
  /*#__PURE__*/
  compose(background, backgroundColor, backgroundImage, backgroundSize, backgroundPosition, backgroundRepeat);
  var opacity =
  /*#__PURE__*/
  style({
    prop: 'opacity'
  });
  var overflow =
  /*#__PURE__*/
  style({
    prop: 'overflow'
  });
  var basics =
  /*#__PURE__*/
  compose(opacity, overflow);

  var unit$1 = function unit(_unit) {
    return function (value) {
      return num$1(value) ? "" + value + _unit : value;
    };
  };

  var px$1 =
  /*#__PURE__*/
  unit$1('px');

  var percent = function percent(n) {
    return !num$1(n) || n > 1 ? px$1(n) : n * 100 + "%";
  };

  var getBorder = function getBorder(n) {
    return num$1(n) && n > 0 ? n + "px solid" : n;
  };

  var border =
  /*#__PURE__*/
  style({
    prop: 'border',
    themeKey: 'borders',
    transform: getBorder
  });
  var borderTop =
  /*#__PURE__*/
  style({
    prop: 'borderTop',
    themeKey: 'borders',
    transform: getBorder
  });
  var borderRight =
  /*#__PURE__*/
  style({
    prop: 'borderRight',
    themeKey: 'borders',
    transform: getBorder
  });
  var borderBottom =
  /*#__PURE__*/
  style({
    prop: 'borderBottom',
    themeKey: 'borders',
    transform: getBorder
  });
  var borderLeft =
  /*#__PURE__*/
  style({
    prop: 'borderLeft',
    themeKey: 'borders',
    transform: getBorder
  });
  var borderColor =
  /*#__PURE__*/
  style({
    prop: 'borderColor',
    themeKey: 'colors'
  });
  var borderRadius$1 =
  /*#__PURE__*/
  style({
    prop: 'borderRadius',
    themeKey: 'radii',
    transform: px$1
  });
  var boxShadow =
  /*#__PURE__*/
  style({
    prop: 'boxShadow',
    themeKey: 'shadows'
  });
  var borders =
  /*#__PURE__*/
  compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderRadius$1, boxShadow);
  var width =
  /*#__PURE__*/
  style({
    prop: 'width',
    transform: percent,
    themeKey: 'widths'
  });
  var height =
  /*#__PURE__*/
  style({
    prop: 'height',
    transform: percent,
    themeKey: 'heights'
  });
  var maxWidth =
  /*#__PURE__*/
  style({
    prop: 'maxWidth',
    transform: percent,
    themeKey: 'widths'
  });
  var maxHeight =
  /*#__PURE__*/
  style({
    prop: 'maxHeight',
    transform: percent,
    themeKey: 'heights'
  });
  var minWidth$1 =
  /*#__PURE__*/
  style({
    prop: 'minWidth',
    transform: percent,
    themeKey: 'widths'
  });
  var minHeight =
  /*#__PURE__*/
  style({
    prop: 'minHeight',
    transform: percent,
    themeKey: 'heights'
  });
  var dimensions =
  /*#__PURE__*/
  compose(width, height, maxWidth, maxHeight, minWidth$1, minHeight);
  var display =
  /*#__PURE__*/
  style({
    prop: 'display'
  });
  var alignItems =
  /*#__PURE__*/
  style({
    prop: 'alignItems'
  });
  var alignContent =
  /*#__PURE__*/
  style({
    prop: 'alignContent'
  });
  var justifyContent =
  /*#__PURE__*/
  style({
    prop: 'justifyContent'
  });
  var flexWrap =
  /*#__PURE__*/
  style({
    prop: 'flexWrap'
  });
  var flexBasis =
  /*#__PURE__*/
  style({
    prop: 'flexBasis',
    transform: percent
  });
  var flexDirection =
  /*#__PURE__*/
  style({
    prop: 'flexDirection'
  });
  var flex =
  /*#__PURE__*/
  style({
    prop: 'flex'
  });
  var justifySelf =
  /*#__PURE__*/
  style({
    prop: 'justifySelf'
  });
  var alignSelf =
  /*#__PURE__*/
  style({
    prop: 'alignSelf'
  });
  var order =
  /*#__PURE__*/
  style({
    prop: 'order'
  });
  var flexboxes =
  /*#__PURE__*/
  compose(display, alignItems, alignContent, justifyContent, flexWrap, flexBasis, flexDirection, flex, justifySelf, alignSelf, order);
  var position =
  /*#__PURE__*/
  style({
    prop: 'position'
  });
  var zIndex =
  /*#__PURE__*/
  style({
    prop: 'zIndex',
    themeKey: 'zIndexes'
  });
  var top =
  /*#__PURE__*/
  style({
    prop: 'top',
    transform: px$1
  });
  var right =
  /*#__PURE__*/
  style({
    prop: 'right',
    transform: px$1
  });
  var bottom =
  /*#__PURE__*/
  style({
    prop: 'bottom',
    transform: px$1
  });
  var left =
  /*#__PURE__*/
  style({
    prop: 'left',
    transform: px$1
  });
  var positions =
  /*#__PURE__*/
  compose(position, zIndex, top, right, bottom, left);
  var DEFAULT_SPACING = [0, 8, 16, 24, 32, 40, 48, 56, 64, 72];

  function transform(transformedValue, _ref) {
    var rawValue = _ref.rawValue,
        _ref$variants = _ref.variants,
        variants = _ref$variants === void 0 ? DEFAULT_SPACING : _ref$variants;

    if (!num$1(rawValue)) {
      return variants[rawValue] || rawValue;
    }

    var abs = Math.abs(rawValue);
    var neg = negative(rawValue);
    var value = variants[abs] || abs;

    if (!num$1(value)) {
      return neg ? "-" + value : value;
    }

    return value * (neg ? -1 : 1);
  }

  var themeKey = 'spaces';
  var m =
  /*#__PURE__*/
  style({
    prop: 'm',
    cssProperties: ['margin'],
    themeKey: themeKey,
    transform: transform
  });
  var mt =
  /*#__PURE__*/
  style({
    prop: 'mt',
    cssProperties: ['marginTop'],
    themeKey: themeKey,
    transform: transform
  });
  var mr =
  /*#__PURE__*/
  style({
    prop: 'mr',
    cssProperties: ['marginRight'],
    themeKey: themeKey,
    transform: transform
  });
  var mb =
  /*#__PURE__*/
  style({
    prop: 'mb',
    cssProperties: ['marginBottom'],
    themeKey: themeKey,
    transform: transform
  });
  var ml =
  /*#__PURE__*/
  style({
    prop: 'ml',
    cssProperties: ['marginLeft'],
    themeKey: themeKey,
    transform: transform
  });
  var mx =
  /*#__PURE__*/
  style({
    prop: 'mx',
    cssProperties: ['marginRight', 'marginLeft'],
    themeKey: themeKey,
    transform: transform
  });
  var my =
  /*#__PURE__*/
  style({
    prop: 'my',
    cssProperties: ['marginTop', 'marginBottom'],
    themeKey: themeKey,
    transform: transform
  });
  var p =
  /*#__PURE__*/
  style({
    prop: 'p',
    cssProperties: ['padding'],
    themeKey: themeKey,
    transform: transform
  });
  var pt =
  /*#__PURE__*/
  style({
    prop: 'pt',
    cssProperties: ['paddingTop'],
    themeKey: themeKey,
    transform: transform
  });
  var pr =
  /*#__PURE__*/
  style({
    prop: 'pr',
    cssProperties: ['paddingRight'],
    themeKey: themeKey,
    transform: transform
  });
  var pb =
  /*#__PURE__*/
  style({
    prop: 'pb',
    cssProperties: ['paddingBottom'],
    themeKey: themeKey,
    transform: transform
  });
  var pl =
  /*#__PURE__*/
  style({
    prop: 'pl',
    cssProperties: ['paddingLeft'],
    themeKey: themeKey,
    transform: transform
  });
  var px$1$1 =
  /*#__PURE__*/
  style({
    prop: 'px',
    cssProperties: ['paddingRight', 'paddingLeft'],
    themeKey: themeKey,
    transform: transform
  });
  var py =
  /*#__PURE__*/
  style({
    prop: 'py',
    cssProperties: ['paddingTop', 'paddingBottom'],
    themeKey: themeKey,
    transform: transform
  });
  var space =
  /*#__PURE__*/
  compose(m, mt, mr, mb, ml, mx, my, p, pt, pr, pb, pl, px$1$1, py);
  var fontFamily$1 =
  /*#__PURE__*/
  style({
    prop: 'fontFamily',
    themeKey: 'fonts'
  });
  var fontSize =
  /*#__PURE__*/
  style({
    prop: 'fontSize',
    themeKey: 'fontSizes'
  });
  var lineHeight =
  /*#__PURE__*/
  style({
    prop: 'lineHeight',
    themeKey: 'lineHeights'
  });
  var fontWeight =
  /*#__PURE__*/
  style({
    prop: 'fontWeight',
    themeKey: 'fontWeights'
  });
  var textAlign =
  /*#__PURE__*/
  style({
    prop: 'textAlign'
  });
  var letterSpacing =
  /*#__PURE__*/
  style({
    prop: 'letterSpacing',
    themeKey: 'letterSpacings',
    transform: px$1
  });
  var color =
  /*#__PURE__*/
  style({
    prop: 'color',
    themeKey: 'colors'
  });
  var textTransform =
  /*#__PURE__*/
  style({
    prop: 'textTransform'
  });
  var typography =
  /*#__PURE__*/
  compose(fontFamily$1, fontSize, lineHeight, fontWeight, textAlign, letterSpacing, color, textTransform);
  var system =
  /*#__PURE__*/
  compose(backgrounds, basics, borders, dimensions, flexboxes, positions, space, typography);



  var systemDefs = /*#__PURE__*/Object.freeze({
    colors: colors,
    fontSizes: fontSizes,
    spaces: spaces
  });

  var defaultSystemTheme =
  /*#__PURE__*/
  definitionsToTheme(systemDefs);

  function getProps(props, defaultProps) {
    var theme = _objectSpread({}, defaultSystemTheme, getTheme(props));

    return _objectSpread({}, defaultProps, props, {
      theme: theme
    });
  }

  function createComponent(getConfig) {
    var _getConfig = getConfig(),
        name = _getConfig.name,
        style$$1 = _getConfig.style,
        _getConfig$omitProps = _getConfig.omitProps,
        omitProps = _getConfig$omitProps === void 0 ? [] : _getConfig$omitProps,
        _getConfig$defaultPro = _getConfig.defaultProps,
        defaultProps = _getConfig$defaultPro === void 0 ? {} : _getConfig$defaultPro,
        _getConfig$propTypes = _getConfig.propTypes,
        propTypes = _getConfig$propTypes === void 0 ? {} : _getConfig$propTypes,
        _getConfig$render = _getConfig.render,
        _render = _getConfig$render === void 0 ? function (_ref) {
      var Component = _ref.Component,
          props = _objectWithoutPropertiesLoose(_ref, ["Component"]);

      return React__default.createElement(Component, props);
    } : _getConfig$render,
        _getConfig$defaultCom = _getConfig.defaultComponent,
        defaultComponent = _getConfig$defaultCom === void 0 ? 'div' : _getConfig$defaultCom,
        _getConfig$system = _getConfig.system,
        system$$1 = _getConfig$system === void 0 ? system : _getConfig$system,
        _getConfig$applySyste = _getConfig.applySystem,
        applySystem = _getConfig$applySyste === void 0 ? function (system$$1) {
      return function (props) {
        return {
          '&&': system$$1.props(props)
        };
      };
    } : _getConfig$applySyste,
        InnerComponentFromConfig = _getConfig.InnerComponent;

    var omittedProps = ['theme'].concat(system$$1 ? system$$1.meta.props : {}, omitProps);
    var baseClassName = "sui-" + name;

    var InnerComponent = InnerComponentFromConfig ||
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(Component, _React$Component);

      function Component() {
        return _React$Component.apply(this, arguments) || this;
      }

      var _proto = Component.prototype;

      _proto.render = function render() {
        var _this$props = this.props,
            className = _this$props.className,
            as = _this$props.as,
            forwardedRef = _this$props.forwardedRef,
            props = _objectWithoutPropertiesLoose(_this$props, ["className", "as", "forwardedRef"]);

        var Component = as || defaultComponent;

        var renderProps = _objectSpread({
          ref: forwardedRef,
          Component: Component,
          className: className ? baseClassName + " " + className : baseClassName
        }, omit(props, omittedProps));

        return _render(renderProps);
      };

      return Component;
    }(React__default.Component);

    InnerComponent.displayName = "sui-" + name;

    function forwardRef(props, ref) {
      return React__default.createElement(InnerComponent, _extends({}, props, {
        forwardedRef: ref
      }));
    }

    forwardRef.displayName = InnerComponent.displayName;
    var RefComponent = React__default.forwardRef(forwardRef);
    RefComponent.displayName = InnerComponent.displayName;
    var StyledComponent = styled__default(RefComponent)(function (p$$1) {
      var styles = [];
      var props = getProps(p$$1, defaultProps);

      if (func(style$$1)) {
        styles.push(style$$1(props));
      }

      if (func(applySystem)) {
        styles.push(applySystem(system$$1)(props));
      }

      return styles;
    });
    StyledComponent.propTypes = _objectSpread({
      theme: PropTypes.object
    }, system$$1 ? system$$1.meta.props.reduce(function (obj, prop) {
      obj[prop] = PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object]);
      return obj;
    }, {}) : {}, propTypes);
    StyledComponent.defaultProps = _objectSpread({}, defaultProps);
    return StyledComponent;
  }

  var Alert =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'alert',
      omitProps: ['variant'],
      style: function style(p) {
        return styled.css(["position:relative;padding:", " ", ";margin-bottom:", ";border:1px solid transparent;border-radius:", ";", ";"], alertPaddingY(p), alertPaddingX(p), alertMarginBottom(p), borderRadius(p), p.variant && alertVariant(p.variant)(p));
      },
      propTypes: {
        children: PropTypes.node,
        variant: PropTypes.string
      },
      defaultProps: {
        variant: 'primary'
      }
    };
  });

  var Box =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'box'
    };
  });

  var Breakpoint =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'breakpoint',
      omitProps: ['up', 'down'],
      style: function style(p) {
        return styled.css(["display:none;", ";", ";"], p.up && up(p.up, 'display: block;')(p), p.down && down(p.down, 'display: block;')(p));
      },
      propTypes: {
        children: PropTypes.node,
        up: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
        down: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
      }
    };
  });

  var btnSize = {
    sm: function sm(p) {
      return styled.css(["padding:", " ", ";font-size:", ";border-radius:", ";line-height:", ";"], btnPaddingYSm(p), btnPaddingXSm(p), fontSizeSm(p), borderRadiusSm(p), btnLineHeightSm(p));
    },
    md: function md(p) {
      return styled.css(["padding:", " ", ";font-size:", ";border-radius:", ";line-height:", ";"], btnPaddingY(p), btnPaddingX(p), fontSizeBase(p), borderRadius(p), btnLineHeight(p));
    },
    lg: function lg(p) {
      return styled.css(["padding:", " ", ";font-size:", ";border-radius:", ";line-height:", ";"], btnPaddingYLg(p), btnPaddingXLg(p), fontSizeLg(p), borderRadiusLg(p), btnLineHeightLg(p));
    }
  };
  var Button =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'button',
      defaultComponent: 'button',
      omitProps: ['size', 'variant'],
      style: function style(p) {
        return styled.css(["display:inline-block;z-index:", ";border-width:", ";cursor:pointer;", ";text-decoration:none;&:disabled{opacity:", ";}", ";", ";"], zIndexControl(p), btnBorderWidth(p), transitionBase(p), btnDisabledOpacity(p), p.size && btnSize[p.size] && btnSize[p.size](p), p.variant && btnVariant(p.variant)(p));
      },
      propTypes: {
        children: PropTypes.node,
        disabled: PropTypes.bool,
        size: PropTypes.oneOf(['sm', 'md', 'lg']),
        variant: PropTypes.string
      },
      defaultProps: {
        size: 'md',
        variant: 'primary'
      }
    };
  });

  function create() {
    var SwitchState =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(SwitchState, _Component);

      function SwitchState() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          focused: false,
          checked: _this.props.checked || _this.props.defaultChecked || false
        };

        _this.handleChange = function (event) {
          if (_this.props.checked === undefined) {
            _this.setState({
              checked: event.currentTarget.checked
            });
          }

          if (_this.props.onChange) {
            _this.props.onChange(event);
          }
        };

        _this.handleFocus = function (event) {
          _this.setState({
            focused: true
          });

          if (_this.props.onFocus) {
            _this.props.onFocus(event);
          }
        };

        _this.handleBlur = function (event) {
          _this.setState({
            focused: false
          });

          if (_this.props.onBlur) {
            _this.props.onBlur(event);
          }
        };

        return _this;
      }

      SwitchState.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        if (props.checked !== undefined && props.checked !== state.checked) {
          return _objectSpread({}, state, {
            checked: props.checked
          });
        }

        return state;
      };

      var _proto = SwitchState.prototype;

      _proto.render = function render() {
        var _this$props = this.props,
            checked = _this$props.checked,
            children = _this$props.children,
            defaultChecked = _this$props.defaultChecked,
            onChange = _this$props.onChange,
            onBlur = _this$props.onBlur,
            onFocus = _this$props.onFocus,
            style = _this$props.style,
            props = _objectWithoutPropertiesLoose(_this$props, ["checked", "children", "defaultChecked", "onChange", "onBlur", "onFocus", "style"]);

        return this.props.children({
          focused: this.state.focused,
          checked: this.state.checked,
          disabled: props.disabled,
          input: _objectSpread({
            checked: this.state.checked,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            style: _objectSpread({
              position: 'absolute',
              margin: 0,
              padding: 0,
              top: 0,
              right: 0,
              left: 0,
              bottom: 0,
              opacity: 0,
              width: '100%',
              height: '100%',
              zIndex: 10
            }, style)
          }, props)
        });
      };

      return SwitchState;
    }(React.Component);

    return SwitchState;
  }

  var SwitchState = /*#__PURE__*/
  create();

  var sizeStyle = {
    sm: function sm(p$$1) {
      return styled.css([".sui-checkbox-content{border-radius:", ";width:0.875rem;height:0.875rem;}.sui-checkbox-check{width:8px;height:8px;}"], borderRadiusSm(p$$1));
    },
    md: function md(p$$1) {
      return styled.css([".sui-checkbox-content{border-radius:", ";width:1rem;height:1rem;}.sui-checkbox-check{width:10px;height:10px;}"], borderRadius(p$$1));
    },
    lg: function lg(p$$1) {
      return styled.css([".sui-checkbox-content{border-radius:", ";width:1.25rem;height:1.25rem;}.sui-checkbox-check{width:12px;height:12px;}"], borderRadiusLg(p$$1));
    }
  };

  var validStyle = function validStyle(p$$1) {
    var valid = p$$1.valid;
    if (valid !== true && valid !== false) return null;
    var color$$1 = valid ? success(p$$1) : danger(p$$1);
    return styled.css(["input + .sui-checkbox-content,input:checked + .sui-checkbox-content{border-color:", ";}input:checked + .sui-checkbox-content{background-color:", ";}input:focus + .sui-checkbox-content{border-color:", ";", "}"], color$$1, color$$1, color$$1, controlFocus(color$$1)(p$$1));
  };

  var controlStyle = function controlStyle(p$$1) {
    return styled.css(["input:focus + .sui-checkbox-content{", "}", ";"], controlFocus(primary(p$$1))(p$$1), validStyle(p$$1));
  };

  var containerSystem =
  /*#__PURE__*/
  compose(basics, dimensions, space, flexboxes, positions);
  var contentSystem =
  /*#__PURE__*/
  compose(dimensions, backgrounds, borders);
  var system$1 =
  /*#__PURE__*/
  compose(containerSystem, contentSystem);
  var Checkbox =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'checkbox',
      omitProps: ['control', 'valid'],
      system: system$1,
      applySystem: null,
      render: function render(_ref) {
        var Component = _ref.Component,
            ref = _ref.ref,
            className = _ref.className,
            size = _ref.size,
            props = _objectWithoutPropertiesLoose(_ref, ["Component", "ref", "className", "size"]);

        return React__default.createElement(SwitchState, props, function (_ref2) {
          var input = _ref2.input;
          return React__default.createElement(Component, {
            className: className
          }, React__default.createElement("input", _extends({
            ref: ref,
            type: "checkbox"
          }, input)), React__default.createElement("div", {
            className: "sui-checkbox-content"
          }, React__default.createElement("svg", {
            className: "sui-checkbox-check",
            viewBox: "0 0 512 512"
          }, React__default.createElement("path", {
            fill: "currentColor",
            d: "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
          }))));
        });
      },
      style: function style$$1(p$$1) {
        return styled.css(["display:inline-flex;align-items:center;justify-content:center;position:relative;width:1.5rem;height:1.5rem;z-index:", ";.sui-checkbox-check{pointer-events:none;transform:scale(0);transform-origin:center;color:", ";", ";}.sui-checkbox-content{display:flex;align-items:center;justify-content:center;width:1rem;height:1rem;background-color:", ";border-radius:", ";border-style:solid;border-width:", ";border-color:", ";", ";}input:checked + .sui-checkbox-content{background-color:", ";border-color:transparent;svg{transform:scale(1);}}input:focus + .sui-checkbox-content{", ";}input:disabled + .sui-checkbox-content{background-color:", ";}", ";", ";", ";.sui-checkbox-content{", ";}"], zIndexControl(p$$1), white(p$$1), transitionBase(p$$1), inputBgColor(p$$1), borderRadius(p$$1), inputBorderWidth(p$$1), inputBorderColor(p$$1), transitionBase(p$$1), primary(p$$1), baseFocus(primary(p$$1))(p$$1), inputDisabledBgColor(p$$1), sizeStyle[p$$1.size] && sizeStyle[p$$1.size] && sizeStyle[p$$1.size](p$$1), p$$1.control && controlStyle(p$$1), containerSystem.props, contentSystem.props);
      },
      propTypes: {
        checked: PropTypes.bool,
        control: PropTypes.bool,
        disabled: PropTypes.bool,
        onChange: PropTypes.func,
        size: PropTypes.oneOf(['sm', 'md', 'lg']),
        valid: PropTypes.bool,
        value: PropTypes.string
      },
      defaultProps: {
        size: 'md'
      }
    };
  });

  var common = {
    position: 'relative',
    width: '100%',
    minHeight: '1px'
  };

  function isValidSize(size) {
    return size || size === 0;
  }

  function getSizeWidth(size, nbColumns) {
    return Math.round(size / nbColumns * Math.pow(10, 6)) / Math.pow(10, 4) + "%";
  }

  function getOffsetStyle(offsetSize, nbColumns) {
    if (isValidSize(offsetSize)) {
      var marginLeft = getSizeWidth(offsetSize, nbColumns);
      return {
        marginLeft: marginLeft
      };
    }

    return null;
  }

  function getBreakPointStyle(breakpoint, width, p) {
    var size = p[breakpoint];
    if (!isValidSize(size)) return null;
    var nbColumns = gridColumns(p);
    var mediaQuery = mediaMinWidth(width);

    var media = function media(style) {
      var _ref;

      return width === 0 ? style : (_ref = {}, _ref[mediaQuery] = style, _ref);
    };

    if (size === true) {
      return _objectSpread({}, common, media({
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: '100%'
      }));
    }

    if (size === 'auto') {
      return _objectSpread({}, common, media({
        flex: "0 0 auto",
        maxWidth: 'none',
        width: 'auto'
      }));
    }

    var sizeWidth = getSizeWidth(size, nbColumns);
    return _objectSpread({}, common, media(_objectSpread({
      flex: "0 0 " + sizeWidth,
      maxWidth: sizeWidth
    }, getOffsetStyle(p["o" + breakpoint], nbColumns))));
  }

  function getStyleFromProps(p) {
    var _p$gutter = p.gutter,
        rawGutter = _p$gutter === void 0 ? gridGutter(p) : _p$gutter;
    var gutter = px(rawGutter);
    var bk = breakpoints(p);
    var breakpointsKeys = Object.keys(bk);
    var style = {
      boxSizing: 'border-box',
      paddingLeft: gutter,
      paddingRight: gutter,
      flexBasis: 0,
      flexGrow: 1,
      maxWidth: '100%'
    };
    var index = -1; // eslint-disable-next-line no-plusplus

    while (++index < breakpointsKeys.length) {
      var breakpoint = breakpointsKeys[index];
      Object.assign(style, getBreakPointStyle(breakpoint, bk[breakpoint], p));
    }

    return style;
  }

  function create$1() {
    var Col = createComponent(function () {
      return {
        name: 'col',
        omitProps: ['xs', 'sm', 'md', 'lg', 'xl', 'oxs', 'osm', 'omd', 'olg', 'oxl'],
        style: getStyleFromProps,
        propTypes: {
          children: PropTypes.node,
          gutter: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
          xs: PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.number]),
          sm: PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.number]),
          md: PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.number]),
          lg: PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.number]),
          xl: PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.number]),
          oxs: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          osm: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          omd: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          olg: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          oxl: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
        }
      };
    });
    var Split = createComponent(function () {
      return {
        name: 'col-split',
        style: function style() {
          return styled.css(["width:100% !important;"]);
        }
      };
    });
    Col.Split = Split;
    return Col;
  }

  var Col = /*#__PURE__*/
  create$1();

  var ControlFeedback =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'control-feedback',
      omitProps: ['valid'],
      style: function style(p) {
        return styled.css(["width:100%;margin-top:0.25rem;font-size:80%;color:", ";"], p.valid ? success(p) : danger(p));
      },
      propTypes: {
        children: PropTypes.node,
        valid: PropTypes.bool.isRequired
      }
    };
  });

  var inlineStyle =
  /*#__PURE__*/
  styled.css(["display:inline-flex;margin-right:0.75rem;"]);
  var FormCheck =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'form-check',
      omitProps: ['inline'],
      style: function style(p) {
        return styled.css(["display:flex;align-items:center;", ";"], p.inline && inlineStyle);
      },
      propTypes: {
        children: PropTypes.node,
        inline: PropTypes.bool
      }
    };
  });

  var FormCheckLabel =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'form-check-label',
      defaultComponent: 'label',
      style: function style(p) {
        return styled.css(["padding-left:0.25rem;[class*='disabled'] ~ &{color:", ";}"], inputDisabledText(p));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var FormGroup =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'form-group',
      style: function style() {
        return styled.css(["margin-bottom:1rem;"]);
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  function _templateObject() {
    var data = _taggedTemplateLiteralLoose(["\n  ", "\n  html,\n  body {\n    font-family: ", ";\n    font-size: ", ";\n    line-height: ", ";\n    -webkit-font-smoothing: antialiased;\n  }\n\n  * {\n    box-sizing: border-box;\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }
  var Normalize =
  /*#__PURE__*/
  styled.createGlobalStyle(
  /*#__PURE__*/
  _templateObject(),
  /*#__PURE__*/
  polished.normalize(), fontFamily, fontSizeBase, lineHeightBase);

  var styleBreakpoints = function styleBreakpoints(p) {
    var bk = breakpoints(p);
    var maxWidths = gridMaxWidths(p);

    var style = function style(breakpoint) {
      var width = bk[breakpoint];

      var media = function media(s) {
        var _ref;

        return width === 0 ? s : (_ref = {}, _ref[mediaMinWidth(width)] = s, _ref);
      };

      return media({
        maxWidth: maxWidths[breakpoint]
      });
    };

    return Object.keys(bk).reduce(function (obj, breakpoint) {
      return Object.assign(obj, style(breakpoint));
    }, {});
  };

  var Grid =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'grid',
      omitProps: ['gutter', 'fluid'],
      style: function style(p) {
        var _p$gutter = p.gutter,
            rawGutter = _p$gutter === void 0 ? gridGutter(p) : _p$gutter;
        var gutter = px(rawGutter);
        return _objectSpread({
          width: '100%',
          paddingRight: gutter,
          paddingLeft: gutter,
          marginRight: 'auto',
          marginLeft: 'auto'
        }, p.fluid ? null : styleBreakpoints(p));
      },
      propTypes: {
        children: PropTypes.node,
        gutter: PropTypes.number,
        fluid: PropTypes.bool
      }
    };
  });

  var sizeStyle$1 = {
    sm: function sm(p) {
      return styled.css(["padding:", " ", ";font-size:", ";line-height:", ";border-radius:", ";"], inputPaddingYSm(p), inputPaddingXSm(p), fontSizeSm(p), inputLineHeightSm(p), borderRadiusSm(p));
    },
    md: function md(p) {
      return styled.css(["padding:", " ", ";font-size:", ";line-height:", ";border-radius:", ";"], inputPaddingY(p), inputPaddingX(p), fontSizeBase(p), inputLineHeight(p), borderRadius(p));
    },
    lg: function lg(p) {
      return styled.css(["padding:", " ", ";font-size:", ";line-height:", ";border-radius:", ";"], inputPaddingYLg(p), inputPaddingXLg(p), fontSizeLg(p), inputLineHeightLg(p), borderRadiusLg(p));
    }
  };

  var validStyle$1 = function validStyle(p) {
    var valid = p.valid;
    if (valid !== true && valid !== false) return null;
    var color = valid ? success(p) : danger(p);
    return styled.css(["border-color:", ";&:focus{border-color:", ";", "}"], color, color, controlFocus(color)(p));
  };

  var controlStyle$1 = function controlStyle(p) {
    return styled.css(["display:block;width:100%;&:focus{", "}", ";"], controlFocus(primary(p))(p), validStyle$1(p));
  };

  var Input =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'input',
      defaultComponent: 'input',
      omitProps: ['control', 'size', 'valid'],
      style: function style(p) {
        return styled.css(["display:inline-block;border-width:", ";border-color:", ";border-style:solid;line-height:", ";color:", ";", ";background-color:", ";&[type='number']{padding-right:6px;}&::placeholder{color:", ";}&:focus{", "}&:disabled{background-color:", ";color:", ";}", ";", ";"], inputBorderWidth(p), inputBorderColor(p), inputLineHeight(p), inputTextColor(p), transitionBase(p), inputBgColor(p), inputPlaceholderText(p), baseFocus(primary(p))(p), inputDisabledBgColor(p), inputDisabledText(p), p.size && sizeStyle$1[p.size] && sizeStyle$1[p.size](p), p.control && controlStyle$1(p));
      },
      propTypes: {
        control: PropTypes.bool,
        size: PropTypes.oneOf(['sm', 'md', 'lg']),
        valid: PropTypes.bool
      },
      defaultProps: {
        size: 'md'
      }
    };
  });

  /* eslint-disable jsx-a11y/label-has-for */
  var Label =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'label',
      defaultComponent: 'label',
      style: function style() {
        return styled.css(["display:inline-block;margin-bottom:0.5rem;"]);
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
  });

  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var inheritsLoose = _inheritsLoose$1;

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized$1;

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty$1;

  var toArray = function toArray(a) {
    var ret = Array(a.length);

    for (var i = 0; i < a.length; ++i) {
      ret[i] = a[i];
    }

    return ret;
  };
  var arrayFind = function arrayFind(array, search) {
    return array.filter(function (a) {
      return a === search;
    })[0];
  };

  var tabSort = function tabSort(a, b) {
    var tabDiff = a.tabIndex - b.tabIndex;
    var indexDiff = a.index - b.index;

    if (tabDiff) {
      if (!a.tabIndex) return 1;
      if (!b.tabIndex) return -1;
    }

    return tabDiff || indexDiff;
  };
  var orderByTabIndex = function orderByTabIndex(nodes, filterNegative) {
    return toArray(nodes).map(function (node, index) {
      return {
        node: node,
        index: index,
        tabIndex: node.tabIndex
      };
    }).filter(function (data) {
      return !filterNegative || data.tabIndex >= 0;
    }).sort(tabSort);
  };

  var tabbables = ['button:enabled:not([readonly])', 'select:enabled:not([readonly])', 'textarea:enabled:not([readonly])', 'input:enabled:not([readonly])', 'a[href]', 'area[href]', 'iframe', 'object', 'embed', '[tabindex]', '[contenteditable]', '[autofocus]'];

  var FOCUS_GROUP = 'data-focus-lock';
  var FOCUS_DISABLED = 'data-focus-lock-disabled';
  var FOCUS_ALLOW = 'data-no-focus-lock';
  var FOCUS_AUTO = 'data-autofocus-inside';

  var getFocusables = function getFocusables(parents) {
    return parents.reduce(function (acc, parent) {
      return acc.concat(toArray(parent.querySelectorAll(tabbables.join(','))));
    }, []);
  };
  var getParentAutofocusables = function getParentAutofocusables(parent) {
    var parentFocus = parent.querySelectorAll('[' + FOCUS_AUTO + ']');
    return toArray(parentFocus).map(function (node) {
      return getFocusables([node]);
    }).reduce(function (acc, nodes) {
      return acc.concat(nodes);
    }, []);
  };

  var isElementHidden = function isElementHidden(computedStyle) {
    if (!computedStyle || !computedStyle.getPropertyValue) {
      return false;
    }

    return computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden';
  };

  var isVisible = function isVisible(node) {
    return !node || node === document || !isElementHidden(window.getComputedStyle(node, null)) && isVisible(node.parentNode);
  };
  var notHiddenInput = function notHiddenInput(node) {
    return !((node.tagName === 'INPUT' || node.tagName === 'BUTTON') && (node.type === 'hidden' || node.disabled));
  };

  var getParents = function getParents(node) {
    var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    parents.push(node);

    if (node.parentNode) {
      getParents(node.parentNode, parents);
    }

    return parents;
  };

  var getCommonParent = function getCommonParent(nodea, nodeb) {
    var parentsA = getParents(nodea);
    var parentsB = getParents(nodeb);

    for (var i = 0; i < parentsA.length; i += 1) {
      var currentParent = parentsA[i];

      if (parentsB.indexOf(currentParent) >= 0) {
        return currentParent;
      }
    }

    return false;
  };
  var filterFocusable = function filterFocusable(nodes) {
    return toArray(nodes).filter(function (node) {
      return isVisible(node);
    }).filter(function (node) {
      return notHiddenInput(node);
    });
  };
  var getTabbableNodes = function getTabbableNodes(topNodes) {
    return orderByTabIndex(filterFocusable(getFocusables(topNodes)), true);
  };
  var getAllTabbableNodes = function getAllTabbableNodes(topNodes) {
    return orderByTabIndex(filterFocusable(getFocusables(topNodes)), false);
  };
  var parentAutofocusables = function parentAutofocusables(topNode) {
    return filterFocusable(getParentAutofocusables(topNode));
  };

  var isRadio = function isRadio(node) {
    return node.tagName === 'INPUT' && node.type === 'radio';
  };

  var findSelectedRadio = function findSelectedRadio(node, nodes) {
    return nodes.filter(isRadio).filter(function (el) {
      return el.name === node.name;
    }).filter(function (el) {
      return el.checked;
    })[0] || node;
  };

  var pickFirstFocus = function pickFirstFocus(nodes) {
    if (nodes[0] && nodes.length > 1) {
      if (isRadio(nodes[0]) && nodes[0].name) {
        return findSelectedRadio(nodes[0], nodes);
      }
    }

    return nodes[0];
  };

  var filterNested = function filterNested(nodes) {
    var l = nodes.length;
    var i = void 0;
    var j = void 0;

    for (i = 0; i < l; i += 1) {
      for (j = 0; j < l; j += 1) {
        if (i !== j) {
          if (nodes[i].contains(nodes[j])) {
            return filterNested(nodes.filter(function (x) {
              return x !== nodes[j];
            }));
          }
        }
      }
    }

    return nodes;
  };

  var getTopParent = function getTopParent(node) {
    return node.parentNode ? getTopParent(node.parentNode) : node;
  };

  var getAllAffectedNodes = function getAllAffectedNodes(node) {
    var group = node.getAttribute(FOCUS_GROUP);

    if (group) {
      return filterNested(toArray(getTopParent(node).querySelectorAll('[' + FOCUS_GROUP + '="' + group + '"]:not([' + FOCUS_DISABLED + '="disabled"])')));
    }

    return [node];
  };

  var findAutoFocused = function findAutoFocused(autoFocusables) {
    return function (node) {
      return !!node.autofocus || node.dataset && !!node.dataset.autofocus || autoFocusables.indexOf(node) >= 0;
    };
  };

  var newFocus = function newFocus(innerNodes, outerNodes, activeElement, lastNode, autoFocused) {
    var cnt = innerNodes.length;
    var firstFocus = innerNodes[0];
    var lastFocus = innerNodes[cnt - 1]; // focus is inside

    if (innerNodes.indexOf(activeElement) >= 0) {
      return undefined;
    }

    var activeIndex = outerNodes.indexOf(activeElement);
    var lastIndex = outerNodes.indexOf(lastNode || activeIndex);
    var lastNodeInside = innerNodes.indexOf(lastNode);
    var indexDiff = activeIndex - lastIndex;
    var firstNodeIndex = outerNodes.indexOf(firstFocus);
    var lastNodeIndex = outerNodes.indexOf(lastFocus); // new focus

    if (activeIndex === -1 || lastNodeInside === -1) {
      return innerNodes.indexOf(autoFocused.length ? pickFirstFocus(autoFocused) : pickFirstFocus(innerNodes));
    } // old focus


    if (!indexDiff && lastNodeInside >= 0) {
      return lastNodeInside;
    } // jump out


    if (indexDiff && Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    } // focus above lock


    if (activeIndex <= firstNodeIndex) {
      return cnt - 1;
    } // focus below lock


    if (activeIndex > lastNodeIndex) {
      return 0;
    } // index is inside tab order, but outside Lock


    if (indexDiff) {
      if (Math.abs(indexDiff) > 1) {
        return lastNodeInside;
      }

      return (cnt + lastNodeInside + indexDiff) % cnt;
    } // do nothing


    return undefined;
  };

  var getTopCommonParent = function getTopCommonParent(activeElement, entry, entries) {
    var topCommon = entry;
    entries.forEach(function (subEntry) {
      var common = getCommonParent(activeElement, subEntry);

      if (common) {
        if (common.contains(topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
    return topCommon;
  };

  var allParentAutofocusables = function allParentAutofocusables(entries) {
    return entries.reduce(function (acc, node) {
      return acc.concat(parentAutofocusables(node));
    }, []);
  };

  var notAGuard = function notAGuard(node) {
    return !(node.dataset && node.dataset.focusGuard);
  };

  var getFocusMerge = function getFocusMerge(topNode, lastNode) {
    var activeElement = document && document.activeElement;
    var entries = getAllAffectedNodes(topNode).filter(notAGuard);
    var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
    var innerElements = getTabbableNodes(entries).filter(function (_ref) {
      var node = _ref.node;
      return notAGuard(node);
    });

    if (!innerElements[0]) {
      innerElements = getAllTabbableNodes(entries).filter(function (_ref2) {
        var node = _ref2.node;
        return notAGuard(node);
      });

      if (!innerElements[0]) {
        return undefined;
      }
    }

    var innerNodes = innerElements.map(function (_ref3) {
      var node = _ref3.node;
      return node;
    });
    var outerNodes = getTabbableNodes([commonParent]).map(function (_ref4) {
      var node = _ref4.node;
      return node;
    });
    var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode, innerNodes.filter(findAutoFocused(allParentAutofocusables(entries))));

    if (newId === undefined) {
      return newId;
    }

    return innerElements[newId];
  };

  var focusInFrame = function focusInFrame(frame) {
    return frame === document.activeElement;
  };

  var focusInsideIframe = function focusInsideIframe(topNode) {
    return getAllAffectedNodes(topNode).reduce(function (result, node) {
      return result || !!arrayFind(toArray(node.querySelectorAll('iframe')), focusInFrame);
    }, false);
  };

  var focusInside = function focusInside(topNode) {
    var activeElement = document && document.activeElement;

    if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
      return false;
    }

    return getAllAffectedNodes(topNode).reduce(function (result, node) {
      return result || node.contains(activeElement) || focusInsideIframe(topNode);
    }, false);
  };

  var focusIsHidden = function focusIsHidden() {
    return document && toArray(document.querySelectorAll('[' + FOCUS_ALLOW + ']')).some(function (node) {
      return node.contains(document.activeElement);
    });
  };

  var focusOn = function focusOn(target) {
    target.focus();

    if (target.contentWindow) {
      target.contentWindow.focus();
    }
  };
  var guardCount = 0;
  var lockDisabled = false;
  var setFocus = (function (topNode, lastNode) {
    var focusable = getFocusMerge(topNode, lastNode);

    if (lockDisabled) {
      return;
    }

    if (focusable) {
      if (guardCount > 2) {
        if (process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line no-console
          console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' + 'See https://github.com/theKashey/focus-lock/#focus-fighting');
          lockDisabled = true;
          setTimeout(function () {
            lockDisabled = false;
          }, 1);
        }

        return;
      }

      guardCount++;
      focusOn(focusable.node);
      guardCount--;
    }
  });

  //
  var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

    if (ret !== void 0) {
      return !!ret;
    }

    if (objA === objB) {
      return true;
    }

    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB); // Test for A's keys different from B.

    for (var idx = 0; idx < keysA.length; idx++) {
      var key = keysA[idx];

      if (!bHasOwnProperty(key)) {
        return false;
      }

      var valueA = objA[key];
      var valueB = objB[key];
      ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

      if (ret === false || ret === void 0 && valueA !== valueB) {
        return false;
      }
    }

    return true;
  };

  function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
    if (process.env.NODE_ENV !== "production") {
      if (typeof reducePropsToState !== 'function') {
        throw new Error('Expected reducePropsToState to be a function.');
      }

      if (typeof handleStateChangeOnClient !== 'function') {
        throw new Error('Expected handleStateChangeOnClient to be a function.');
      }
    }

    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName || WrappedComponent.name || 'Component';
    }

    return function wrap(WrappedComponent) {
      if (process.env.NODE_ENV !== "production") {
        if (typeof WrappedComponent !== 'function') {
          throw new Error('Expected WrappedComponent to be a React component.');
        }
      }

      var mountedInstances = [];
      var state;

      function emitChange() {
        state = reducePropsToState(mountedInstances.map(function (instance) {
          return instance.props;
        }));
        handleStateChangeOnClient(state);
      }

      var SideEffect =
      /*#__PURE__*/
      function (_Component) {
        inheritsLoose(SideEffect, _Component);

        function SideEffect() {
          return _Component.apply(this, arguments) || this;
        } // Try to use displayName of wrapped component


        SideEffect.peek = function peek() {
          return state;
        };

        var _proto = SideEffect.prototype;

        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
          return !shallowequal(nextProps, this.props);
        };

        _proto.componentDidMount = function componentDidMount() {
          mountedInstances.push(this);
          emitChange();
        };

        _proto.componentDidUpdate = function componentDidUpdate() {
          emitChange();
        };

        _proto.componentWillUnmount = function componentWillUnmount() {
          var index = mountedInstances.indexOf(this);
          mountedInstances.splice(index, 1);
          emitChange();
        };

        _proto.render = function render() {
          return React__default.createElement(WrappedComponent, this.props);
        };

        return SideEffect;
      }(React.Component);

      defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");

      return SideEffect;
    };
  }

  function deferAction(action) {
    // Hidding setImmediate from Webpack to avoid inserting polyfill
    var setImmediate = window.setImmediate;

    if (typeof setImmediate !== 'undefined') {
      setImmediate(action);
    } else {
      setTimeout(action, 1);
    }
  }
  var inlineProp = function inlineProp(name, value) {
    var obj = {};
    obj[name] = value;
    return obj;
  };

  var focusOnBody = function focusOnBody() {
    return document && document.activeElement === document.body;
  };

  var isFreeFocus = function isFreeFocus() {
    return focusOnBody() || focusIsHidden();
  };

  var lastActiveTrap = null;
  var lastActiveFocus = null;
  var lastPortaledElement = null;

  var defaultWhitelist = function defaultWhitelist() {
    return true;
  };

  var focusWhitelisted = function focusWhitelisted(activeElement) {
    return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
  };

  var recordPortal = function recordPortal(observerNode, portaledElement) {
    lastPortaledElement = {
      observerNode: observerNode,
      portaledElement: portaledElement
    };
  };

  var focusIsPortaledPair = function focusIsPortaledPair(element) {
    return lastPortaledElement && lastPortaledElement.portaledElement === element;
  };

  var activateTrap = function activateTrap() {
    var result = false;

    if (lastActiveTrap) {
      var _lastActiveTrap = lastActiveTrap,
          observed = _lastActiveTrap.observed,
          persistentFocus = _lastActiveTrap.persistentFocus,
          autoFocus = _lastActiveTrap.autoFocus;
      var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
      var activeElement = document && document.activeElement;

      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(focusInside(workingNode) || focusIsPortaledPair(activeElement, workingNode))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              activeElement.blur();
              document.body.focus();
            } else {
              result = setFocus(workingNode, lastActiveFocus);
              lastPortaledElement = {};
            }
          }

          lastActiveFocus = document && document.activeElement;
        }
      }
    }

    return result;
  };

  var onTrap = function onTrap(event) {
    if (activateTrap() && event) {
      // prevent scroll jump
      event.stopPropagation();
      event.preventDefault();
    }
  };

  var onBlur = function onBlur() {
    return deferAction(activateTrap);
  };
  var onFocus = function onFocus(event) {
    // detect portal
    var source = event.target;
    var currentNode = event.currentTarget;

    if (!currentNode.contains(source)) {
      recordPortal(currentNode, source);
    }
  };

  var FocusWatcher = function FocusWatcher() {
    return null;
  };

  var FocusTrap = function FocusTrap(_ref) {
    var children = _ref.children;
    return React__default.createElement("div", {
      onBlur: onBlur,
      onFocus: onFocus
    }, children);
  };

  FocusTrap.propTypes = process.env.NODE_ENV !== "production" ? {
    children: PropTypes.node.isRequired
  } : {};

  var attachHandler = function attachHandler() {
    document.addEventListener('focusin', onTrap, true);
    document.addEventListener('focusout', onBlur);
  };

  var detachHandler = function detachHandler() {
    document.removeEventListener('focusin', onTrap, true);
    document.removeEventListener('focusout', onBlur);
  };

  function reducePropsToState(propsList) {
    return propsList.filter(function (_ref2) {
      var disabled = _ref2.disabled;
      return !disabled;
    }).slice(-1)[0];
  }

  function handleStateChangeOnClient(trap) {
    if (trap && !lastActiveTrap) {
      attachHandler();
    }

    var lastTrap = lastActiveTrap;
    var sameTrap = lastTrap && trap && trap.onActivation === lastTrap.onActivation;
    lastActiveTrap = trap;

    if (lastTrap && !sameTrap) {
      lastTrap.onDeactivation();
    }

    if (trap) {
      lastActiveFocus = null;

      if (!sameTrap || lastTrap.observed !== trap.observed) {
        trap.onActivation();
      }

      activateTrap(true);
      deferAction(activateTrap);
    } else {
      detachHandler();
      lastActiveFocus = null;
    }
  }

  var FocusTrap$1 = /*#__PURE__*/
  withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);

  var RenderChildren = function RenderChildren(_ref) {
    var children = _ref.children;
    return React__default.createElement("div", null, children);
  };

  RenderChildren.propTypes = process.env.NODE_ENV !== "production" ? {
    children: PropTypes.node.isRequired
  } : {};
  var Fragment = React__default.Fragment ? React__default.Fragment : RenderChildren;
  var hidden = {
    width: '1px',
    height: '0px',
    padding: 0,
    overflow: 'hidden',
    position: 'fixed',
    top: '1px',
    left: '1px'
  };

  var FocusLock =
  /*#__PURE__*/
  function (_Component) {
    inheritsLoose(FocusLock, _Component);

    function FocusLock() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Component.call.apply(_Component, [this].concat(args)) || this;

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "state", {
        observed: undefined
      });

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onActivation", function () {
        _this.originalFocusedElement = _this.originalFocusedElement || document && document.activeElement;

        if (_this.state.observed && _this.props.onActivation) {
          _this.props.onActivation(_this.state.observed);
        }

        _this.isActive = true;
      });

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onDeactivation", function () {
        _this.isActive = false;

        if (_this.props.returnFocus && _this.originalFocusedElement && _this.originalFocusedElement.focus) {
          _this.originalFocusedElement.focus();

          _this.originalFocusedElement = null;
        }

        if (_this.props.onDeactivation) {
          _this.props.onDeactivation(_this.state.observed);
        }
      });

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onFocus", function (event) {
        if (_this.isActive) {
          onFocus(event);
        }
      });

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onBlur", onBlur);

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "setObserveNode", function (observed) {
        return _this.setState({
          observed: observed
        });
      });

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "isActive", false);

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "update", function () {
        return _this.setState(function (prevState) {
          return {
            escapeAttempts: prevState.escapeAttempts + 1
          };
        });
      });

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "originalFocusedElement", null);

      return _this;
    }

    var _proto = FocusLock.prototype;

    _proto.render = function render() {
      var _extends2;

      var _this$props = this.props,
          children = _this$props.children,
          disabled = _this$props.disabled,
          noFocusGuards = _this$props.noFocusGuards,
          persistentFocus = _this$props.persistentFocus,
          autoFocus = _this$props.autoFocus,
          allowTextSelection = _this$props.allowTextSelection,
          group = _this$props.group,
          className = _this$props.className,
          whiteList = _this$props.whiteList,
          _this$props$as = _this$props.as,
          Container = _this$props$as === void 0 ? 'div' : _this$props$as,
          _this$props$lockProps = _this$props.lockProps,
          containerProps = _this$props$lockProps === void 0 ? {} : _this$props$lockProps;
      var observed = this.state.observed;

      if (process.env.NODE_ENV !== 'production') {
        if (typeof allowTextSelection !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn('React-Focus-Lock: allowTextSelection is deprecated and enabled by default');
        }
      }

      var lockProps = _extends_1((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && 'disabled', _extends2[FOCUS_GROUP] = group, _extends2), containerProps);

      return React__default.createElement(Fragment, null, !noFocusGuards && [React__default.createElement("div", {
        key: "guard-first",
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hidden
      }), // nearest focus guard
      React__default.createElement("div", {
        key: "guard-nearest",
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 1,
        style: hidden
      })], React__default.createElement(Container, _extends_1({
        ref: this.setObserveNode
      }, lockProps, {
        className: className,
        onBlur: this.onBlur,
        onFocus: this.onFocus
      }), React__default.createElement(FocusTrap$1, {
        observed: observed,
        disabled: disabled,
        persistentFocus: persistentFocus,
        autoFocus: autoFocus,
        whiteList: whiteList,
        onActivation: this.onActivation,
        onDeactivation: this.onDeactivation
      }), children), !noFocusGuards && React__default.createElement("div", {
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hidden
      }));
    };

    return FocusLock;
  }(React.Component);

  FocusLock.propTypes = process.env.NODE_ENV !== "production" ? {
    children: PropTypes.node.isRequired,
    disabled: PropTypes.bool,
    returnFocus: PropTypes.bool,
    noFocusGuards: PropTypes.bool,
    allowTextSelection: PropTypes.bool,
    autoFocus: PropTypes.bool,
    persistentFocus: PropTypes.bool,
    group: PropTypes.string,
    className: PropTypes.string,
    whiteList: PropTypes.func,
    as:
    /*#__PURE__*/
    PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
    lockProps: PropTypes.object,
    onActivation: PropTypes.func,
    onDeactivation: PropTypes.func
  } : {};
  FocusLock.defaultProps = {
    disabled: false,
    returnFocus: false,
    noFocusGuards: false,
    autoFocus: true,
    persistentFocus: false,
    allowTextSelection: undefined,
    group: undefined,
    className: undefined,
    whiteList: undefined,
    as: 'div',
    lockProps: {},
    onActivation: undefined,
    onDeactivation: undefined
  };

  var AutoFocusInside = function AutoFocusInside(_ref) {
    var disabled = _ref.disabled,
        children = _ref.children,
        className = _ref.className;
    return React__default.createElement("div", _extends_1({}, inlineProp(FOCUS_AUTO, !disabled), {
      className: className
    }), children);
  };

  AutoFocusInside.propTypes = process.env.NODE_ENV !== "production" ? {
    children: PropTypes.node.isRequired,
    disabled: PropTypes.bool,
    className: PropTypes.string
  } : {};
  AutoFocusInside.defaultProps = {
    disabled: false,
    className: undefined
  };

  var MoveFocusInside =
  /*#__PURE__*/
  function (_Component) {
    inheritsLoose(MoveFocusInside, _Component);

    function MoveFocusInside() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Component.call.apply(_Component, [this].concat(args)) || this;

      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "setObserveNode", function (ref) {
        _this.observed = ref;

        _this.moveFocus();
      });

      return _this;
    }

    var _proto = MoveFocusInside.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.moveFocus();
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (prevProps.disabled && !this.props.disabled) {
        this.moveFocus();
      }
    };

    _proto.moveFocus = function moveFocus() {
      var observed = this.observed;

      if (!this.props.disabled && observed) {
        if (!focusInside(observed)) {
          setFocus(observed, null);
        }
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          children = _this$props.children,
          disabled = _this$props.disabled,
          className = _this$props.className;
      return React__default.createElement("div", _extends_1({}, inlineProp(FOCUS_AUTO, !disabled), {
        ref: this.setObserveNode,
        className: className
      }), children);
    };

    return MoveFocusInside;
  }(React.Component);

  defineProperty(MoveFocusInside, "defaultProps", {
    disabled: false,
    className: undefined
  });
  MoveFocusInside.propTypes = process.env.NODE_ENV !== "production" ? {
    children: PropTypes.node.isRequired,
    disabled: PropTypes.bool,
    className: PropTypes.string
  } : {};

  var FreeFocusInside = function FreeFocusInside(_ref) {
    var children = _ref.children,
        className = _ref.className;
    return React__default.createElement("div", _extends_1({}, inlineProp(FOCUS_ALLOW, true), {
      className: className
    }), children);
  };

  FreeFocusInside.propTypes = process.env.NODE_ENV !== "production" ? {
    children: PropTypes.node.isRequired,
    className: PropTypes.string
  } : {};
  FreeFocusInside.defaultProps = {
    disabled: false,
    className: undefined
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  function makeStyleTag() {
    if (!document) return null;
    var tag = document.createElement('style');
    tag.type = 'text/css';
    return tag;
  }

  function injectStyles(tag, css) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }

  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(tag);
  }

  var stylesheetSinglentone = function stylesheetSinglentone() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function add(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }

        counter++;
      },
      remove: function remove() {
        counter--;

        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };

  var styleSinglentone = function styleSinglentone() {
    var sheet = stylesheetSinglentone();
    return function (_super) {
      __extends(Sheet, _super);

      function Sheet() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      Sheet.prototype.componentDidMount = function () {
        sheet.add(this.props.styles);
      };

      Sheet.prototype.componentWillUnmount = function () {
        sheet.remove();
      };

      Sheet.prototype.render = function () {
        return null;
      };

      return Sheet;
    }(React.PureComponent);
  };

  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };

  var getOffset = function getOffset(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
    return [parseInt(left || '', 10) || 0, parseInt(top || '', 10) || 0, parseInt(right || '', 10) || 0];
  };

  var getGapWidth = function getGapWidth(gapMode) {
    if (gapMode === void 0) {
      gapMode = 'margin';
    }

    if (typeof window === 'undefined') {
      return zeroGap;
    }

    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };

  var Style =
  /*#__PURE__*/
  styleSinglentone();

  var getStyles = function getStyles(_a, allowRelative, gapMode, important) {
    var left = _a.left,
        top = _a.top,
        right = _a.right,
        gap = _a.gap;

    if (gapMode === void 0) {
      gapMode = 'margin';
    }

    return "\n  body {\n    overflow: hidden " + important + ";\n    " + [allowRelative && "position: relative " + important + ";", gapMode == 'margin' && "\n    padding-left: " + left + "px;\n    padding-top: " + top + "px;\n    padding-right: " + right + "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: " + gap + "px " + important + ";\n    ", gapMode == 'padding' && "padding-right: " + gap + "px " + important + ";"].filter(Boolean).join('') + "\n  }\n  \n  .right-scroll-bar-position {\n    right: " + gap + "px " + important + ";\n  }\n  \n  .width-before-scroll-bar {\n    margin-right: " + gap + "px " + important + ";\n  }\n  \n  .right-scroll-bar-position .right-scroll-bar-position {\n    right: 0 " + important + ";\n  }\n  \n  .width-before-scroll-bar .width-before-scroll-bar {\n    margin-right: 0 " + important + ";\n  }\n";
  };

  var zeroRightClassName = 'right-scroll-bar-position';
  var fullWidthClassName = 'width-before-scroll-bar';

  var RemoveScrollBar =
  /*#__PURE__*/
  function (_super) {
    __extends(RemoveScrollBar, _super);

    function RemoveScrollBar() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.state = {
        gap: getGapWidth(_this.props.gapMode)
      };

      _this.onResize = function () {
        _this.forceUpdate();

        if (_this.state.gap && _this.props.dynamic) {
          if (window.innerHeight > document.body.offsetHeight) {
            _this.setState({
              gap: zeroGap
            });
          }
        }
      };

      return _this;
    }

    RemoveScrollBar.prototype.componentDidMount = function () {
      var gap = getGapWidth(this.props.gapMode);

      if (gap !== this.state.gap) {
        this.setState({
          gap: gap
        });
      }

      if (typeof window !== 'undefined') {
        window.addEventListener('resize', this.onResize);
      }
    };

    RemoveScrollBar.prototype.componentWillUnmount = function () {
      if (typeof window !== 'undefined') {
        window.removeEventListener('resize', this.onResize);
      }
    };

    RemoveScrollBar.prototype.componentDidUpdate = function () {
      if (!this.state.gap) {
        var gap = getGapWidth(this.props.gapMode);

        if (gap !== this.state.gap) {
          this.setState({
            gap: gap
          });
        }
      }
    };

    RemoveScrollBar.prototype.render = function () {
      var _a = this.props,
          noRelative = _a.noRelative,
          noImportant = _a.noImportant,
          _b = _a.gapMode,
          gapMode = _b === void 0 ? 'margin' : _b;
      var gap = this.state.gap;
      return gap.gap ? React.createElement(Style, {
        styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : '')
      }) : null;
    };

    return RemoveScrollBar;
  }(React.Component);

  var handleScroll = function handleScroll(endTarget, event, sourceDelta) {
    var delta = sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;

    do {
      var scrollTop = target.scrollTop,
          scrollHeight = target.scrollHeight,
          clientHeight = target.clientHeight;
      availableScroll += scrollHeight - clientHeight - scrollTop;
      availableScrollTop += scrollTop;
      target = target.parentNode;
    } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));

    if (isDeltaPositive && delta > availableScroll) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && -delta > availableScrollTop) {
      shouldCancelScroll = true;
    }

    return shouldCancelScroll;
  };

  var passiveSupported = false;

  if (typeof window !== 'undefined') {
    try {
      var options =
      /*#__PURE__*/
      Object.defineProperty({}, 'passive', {
        get: function get() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener('test', options, options);
      window.removeEventListener('test', options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }

  var aggressive = passiveSupported ? {
    passive: false
  } : false;

  var getTouchY = function getTouchY(event) {
    return event.changedTouches ? event.changedTouches[0].clientY : 0;
  };
  var classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  var RemoveScroll =
  /*#__PURE__*/
  function (_super) {
    __extends(RemoveScroll, _super);

    function RemoveScroll() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.shouldPreventQueue = [];
      _this.touchStart = 0;
      _this.ref = React.createRef();

      _this.shouldPrevent = function (event) {
        if (RemoveScroll.stack[RemoveScroll.stack.length - 1] !== _this) {
          return;
        }

        var delta = event.deltaY || getTouchY(event);

        var sourceEvent = _this.shouldPreventQueue.filter(function (e) {
          return e.name === event.type && e.delta === delta && e.target === event.target;
        })[0];

        if (!sourceEvent && !_this.props.noIsolation || sourceEvent && sourceEvent.should) {
          event.preventDefault();
        }
      };

      _this.shouldCancel = function (name, delta, target, should) {
        var event = {
          name: name,
          delta: delta,
          target: target,
          should: should
        };

        _this.shouldPreventQueue.push(event);

        setTimeout(function () {
          _this.shouldPreventQueue = _this.shouldPreventQueue.filter(function (e) {
            return e !== event;
          });
        }, 1);
      };

      _this.scrollTouchStart = function (event) {
        _this.touchStart = getTouchY(event);
      };

      _this.scrollWheel = function (event) {
        _this.shouldCancel(event.type, event.deltaY, event.target, handleScroll(_this.ref.current, event, event.deltaY));
      };

      _this.scrollTouchMove = function (event) {
        _this.shouldCancel(event.type, getTouchY(event), event.target, handleScroll(_this.ref.current, event, _this.touchStart - getTouchY(event)));
      };

      return _this;
    }

    RemoveScroll.prototype.componentDidMount = function () {
      RemoveScroll.stack.push(this);
      this.componentDidUpdate({
        enabled: false
      });
    };

    RemoveScroll.prototype.componentWillUnmount = function () {
      var _this = this;

      RemoveScroll.stack = RemoveScroll.stack.filter(function (inst) {
        return inst !== _this;
      });
      this.disable();
    };

    RemoveScroll.prototype.componentDidUpdate = function (oldProps) {
      if (oldProps.enabled !== this.props.enabled) {
        if (this.props.enabled) {
          this.enable();
        } else {
          this.disable();
        }
      }
    };

    RemoveScroll.prototype.enable = function () {
      if (typeof document !== 'undefined') {
        document.addEventListener('wheel', this.shouldPrevent, aggressive);
        document.addEventListener('touchmove', this.shouldPrevent, aggressive);
      }
    };

    RemoveScroll.prototype.disable = function () {
      if (typeof window !== 'undefined') {
        document.removeEventListener('wheel', this.shouldPrevent, aggressive);
        document.removeEventListener('touchmove', this.shouldPrevent, aggressive);
      }
    };

    RemoveScroll.prototype.render = function () {
      var _a = this.props,
          forwardProps = _a.forwardProps,
          children = _a.children,
          className = _a.className,
          removeScrollBar = _a.removeScrollBar,
          enabled = _a.enabled;
      var props = {
        ref: this.ref,
        onScrollCapture: this.scrollWheel,
        onWheelCapture: this.scrollWheel,
        onTouchStartCapture: this.scrollTouchStart,
        onTouchMoveCapture: this.scrollTouchMove
      };
      return React.createElement(React.Fragment, null, removeScrollBar && enabled && React.createElement(RemoveScrollBar, {
        gapMode: "margin"
      }), forwardProps ? React.cloneElement(React.Children.only(children), props) : React.createElement("div", _assign({}, props, {
        className: className
      }), children));
    };

    RemoveScroll.classNames = classNames;
    RemoveScroll.stack = [];
    RemoveScroll.defaultProps = {
      enabled: true,
      removeScrollBar: true
    };
    return RemoveScroll;
  }(React.Component);

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function componentWillMount() {
    // Call this.constructor.gDSFP to support sub-classes.
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);

    if (state !== null && state !== undefined) {
      this.setState(state);
    }
  }

  function componentWillReceiveProps(nextProps) {
    // Call this.constructor.gDSFP to support sub-classes.
    // Use the setState() updater to ensure state isn't stale in certain edge cases.
    function updater(prevState) {
      var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
      return state !== null && state !== undefined ? state : null;
    } // Binding "this" is important for shallow renderer support.


    this.setState(updater.bind(this));
  }

  function componentWillUpdate(nextProps, nextState) {
    try {
      var prevProps = this.props;
      var prevState = this.state;
      this.props = nextProps;
      this.state = nextState;
      this.__reactInternalSnapshotFlag = true;
      this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
    } finally {
      this.props = prevProps;
      this.state = prevState;
    }
  } // React may warn about cWM/cWRP/cWU methods being deprecated.
  // Add a flag to suppress these warnings for this special case.


  componentWillMount.__suppressDeprecationWarning = true;
  componentWillReceiveProps.__suppressDeprecationWarning = true;
  componentWillUpdate.__suppressDeprecationWarning = true;

  function polyfill(Component) {
    var prototype = Component.prototype;

    if (!prototype || !prototype.isReactComponent) {
      throw new Error('Can only polyfill class components');
    }

    if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {
      return Component;
    } // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Error if any of these lifecycles are present,
    // Because they would work differently between older and newer (16.3+) versions of React.


    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;

    if (typeof prototype.componentWillMount === 'function') {
      foundWillMountName = 'componentWillMount';
    } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
      foundWillMountName = 'UNSAFE_componentWillMount';
    }

    if (typeof prototype.componentWillReceiveProps === 'function') {
      foundWillReceivePropsName = 'componentWillReceiveProps';
    } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
      foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
    }

    if (typeof prototype.componentWillUpdate === 'function') {
      foundWillUpdateName = 'componentWillUpdate';
    } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
      foundWillUpdateName = 'UNSAFE_componentWillUpdate';
    }

    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
      var componentName = Component.displayName || Component.name;
      var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
      throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') + '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks');
    } // React <= 16.2 does not support static getDerivedStateFromProps.
    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
    // Newer versions of React will ignore these lifecycles if gDSFP exists.


    if (typeof Component.getDerivedStateFromProps === 'function') {
      prototype.componentWillMount = componentWillMount;
      prototype.componentWillReceiveProps = componentWillReceiveProps;
    } // React <= 16.2 does not support getSnapshotBeforeUpdate.
    // As a workaround, use cWU to invoke the new lifecycle.
    // Newer versions of React will ignore that lifecycle if gSBU exists.


    if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
      if (typeof prototype.componentDidUpdate !== 'function') {
        throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');
      }

      prototype.componentWillUpdate = componentWillUpdate;
      var componentDidUpdate = prototype.componentDidUpdate;

      prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
        // 16.3+ will not execute our will-update method;
        // It will pass a snapshot value to did-update though.
        // Older versions will require our polyfilled will-update value.
        // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
        // Because for <= 15.x versions this might be a "prevContext" object.
        // We also can't just check "__reactInternalSnapshot",
        // Because get-snapshot might return a falsy value.
        // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
        var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
        componentDidUpdate.call(this, prevProps, prevState, snapshot);
      };
    }

    return Component;
  }

  var reactLifecyclesCompat_es = /*#__PURE__*/Object.freeze({
    polyfill: polyfill
  });

  var PropTypes$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.classNamesShape = exports.timeoutsShape = void 0;

  var _propTypes =
  /*#__PURE__*/
  _interopRequireDefault(
  /*#__PURE__*/
  PropTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var timeoutsShape = process.env.NODE_ENV !== 'production' ?
  /*#__PURE__*/
  _propTypes.default.oneOfType([_propTypes.default.number,
  /*#__PURE__*/
  _propTypes.default.shape({
    enter: _propTypes.default.number,
    exit: _propTypes.default.number
  }).isRequired]) : null;
  exports.timeoutsShape = timeoutsShape;
  var classNamesShape = process.env.NODE_ENV !== 'production' ?
  /*#__PURE__*/
  _propTypes.default.oneOfType([_propTypes.default.string,
  /*#__PURE__*/
  _propTypes.default.shape({
    enter: _propTypes.default.string,
    exit: _propTypes.default.string,
    active: _propTypes.default.string
  }),
  /*#__PURE__*/
  _propTypes.default.shape({
    enter: _propTypes.default.string,
    enterDone: _propTypes.default.string,
    enterActive: _propTypes.default.string,
    exit: _propTypes.default.string,
    exitDone: _propTypes.default.string,
    exitActive: _propTypes.default.string
  })]) : null;
  exports.classNamesShape = classNamesShape;
  });

  unwrapExports(PropTypes$1);
  var PropTypes_1 = PropTypes$1.classNamesShape;
  var PropTypes_2 = PropTypes$1.timeoutsShape;

  var Transition_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;

  var PropTypes$$1 =
  /*#__PURE__*/
  _interopRequireWildcard(
  /*#__PURE__*/
  PropTypes);

  var _react =
  /*#__PURE__*/
  _interopRequireDefault(
  /*#__PURE__*/
  React__default);

  var _reactDom =
  /*#__PURE__*/
  _interopRequireDefault(
  /*#__PURE__*/
  reactDom__default);





  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var UNMOUNTED = 'unmounted';
  exports.UNMOUNTED = UNMOUNTED;
  var EXITED = 'exited';
  exports.EXITED = EXITED;
  var ENTERING = 'entering';
  exports.ENTERING = ENTERING;
  var ENTERED = 'entered';
  exports.ENTERED = ENTERED;
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the components.
   * It's up to you to give meaning and effect to those states. For example we can
   * add styles to a component when it enters or exits:
   *
   * ```jsx
   * import Transition from 'react-transition-group/Transition';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 0 },
   *   entered:  { opacity: 1 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {(state) => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * As noted the `Transition` component doesn't _do_ anything by itself to its child component.
   * What it does do is track transition states over time so you can update the
   * component (such as by adding styles or classes) when it changes states.
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component begins the
   * "Enter" stage. During this stage, the component will shift from its current transition state,
   * to `'entering'` for the duration of the transition and then to the `'entered'` stage once
   * it's complete. Let's take the following example:
   *
   * ```jsx
   * state = { in: false };
   *
   * toggleEnterState = () => {
   *   this.setState({ in: true });
   * }
   *
   * render() {
   *   return (
   *     <div>
   *       <Transition in={this.state.in} timeout={500} />
   *       <button onClick={this.toggleEnterState}>Click to Enter</button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state and
   * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.
   *
   * ## Timing
   *
   * Timing is often the trickiest part of animation, mistakes can result in slight delays
   * that are hard to pin down. A common example is when you want to add an exit transition,
   * you should set the desired final styles when the state is `'exiting'`. That's when the
   * transition to those styles will start and, if you matched the `timeout` prop with the
   * CSS Transition duration, it will end exactly when the state changes to `'exited'`.
   *
   * > **Note**: For simpler transitions the `Transition` component might be enough, but
   * > take into account that it's platform-agnostic, while the `CSSTransition` component
   * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
   * > in order to make more complex transitions more predictable. For example, even though
   * > classes `example-enter` and `example-enter-active` are applied immediately one after
   * > another, you can still transition from one to the other because of the forced reflow
   * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)
   * > for more info). Take this into account when choosing between `Transition` and
   * > `CSSTransition`.
   */

  exports.EXITING = EXITING;

  var Transition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Transition, _React$Component);

    function Transition(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;

      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }

      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }

    var _proto = Transition.prototype;

    _proto.getChildContext = function getChildContext() {
      return {
        transitionGroup: null // allows for nested Transitions

      };
    };

    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;

      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }

      return null;
    }; // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }


    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;

      if (prevProps !== this.props) {
        var status = this.state.status;

        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }

      this.updateStatus(false, nextStatus);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };

    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;

      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter;
        appear = timeout.appear;
      }

      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };

    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }

      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();

        var node = _reactDom.default.findDOMNode(this);

        if (nextStatus === ENTERING) {
          this.performEnter(node, mounting);
        } else {
          this.performExit(node);
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };

    _proto.performEnter = function performEnter(node, mounting) {
      var _this2 = this;

      var enter = this.props.enter;
      var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
      var timeouts = this.getTimeouts(); // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node);
        });
        return;
      }

      this.props.onEnter(node, appearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(node, appearing); // FIXME: appear timeout?


        _this2.onTransitionEnd(node, timeouts.enter, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(node, appearing);
          });
        });
      });
    };

    _proto.performExit = function performExit(node) {
      var _this3 = this;

      var exit = this.props.exit;
      var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

      if (!exit) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
        return;
      }

      this.props.onExit(node);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(node);

        _this3.onTransitionEnd(node, timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(node);
          });
        });
      });
    };

    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };

    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };

    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    };

    _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
      this.setNextCallback(handler);

      if (node) {
        if (this.props.addEndListener) {
          this.props.addEndListener(node, this.nextCallback);
        }

        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      } else {
        setTimeout(this.nextCallback, 0);
      }
    };

    _proto.render = function render() {
      var status = this.state.status;

      if (status === UNMOUNTED) {
        return null;
      }

      var _this$props = this.props,
          children = _this$props.children,
          childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


      delete childProps.in;
      delete childProps.mountOnEnter;
      delete childProps.unmountOnExit;
      delete childProps.appear;
      delete childProps.enter;
      delete childProps.exit;
      delete childProps.timeout;
      delete childProps.addEndListener;
      delete childProps.onEnter;
      delete childProps.onEntering;
      delete childProps.onEntered;
      delete childProps.onExit;
      delete childProps.onExiting;
      delete childProps.onExited;

      if (typeof children === 'function') {
        return children(status, childProps);
      }

      var child = _react.default.Children.only(children);

      return _react.default.cloneElement(child, childProps);
    };

    return Transition;
  }(_react.default.Component);

  Transition.contextTypes = {
    transitionGroup: PropTypes$$1.object
  };
  Transition.childContextTypes = {
    transitionGroup: function transitionGroup() {}
  };
  Transition.propTypes = process.env.NODE_ENV !== "production" ? {
    /**
     * A `function` child can be used instead of a React element.
     * This function is called with the current transition status
     * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used
     * to apply context specific props to a component.
     *
     * ```jsx
     * <Transition timeout={150}>
     *   {(status) => (
     *     <MyComponent className={`fade fade-${status}`} />
     *   )}
     * </Transition>
     * ```
     */
    children:
    /*#__PURE__*/
    PropTypes$$1.oneOfType([PropTypes$$1.func.isRequired, PropTypes$$1.element.isRequired]).isRequired,

    /**
     * Show the component; triggers the enter or exit states
     */
    in: PropTypes$$1.bool,

    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: PropTypes$$1.bool,

    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: PropTypes$$1.bool,

    /**
     * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
     * If you want to transition on the first mount set `appear` to `true`, and the
     * component will transition in as soon as the `<Transition>` mounts.
     *
     * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
     */
    appear: PropTypes$$1.bool,

    /**
     * Enable or disable enter transitions.
     */
    enter: PropTypes$$1.bool,

    /**
     * Enable or disable exit transitions.
     */
    exit: PropTypes$$1.bool,

    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided
     *
     * You may specify a single timeout for all transitions like: `timeout={500}`,
     * or individually like:
     *
     * ```jsx
     * timeout={{
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * @type {number | { enter?: number, exit?: number }}
     */
    timeout: function timeout(props) {
      var pt = process.env.NODE_ENV !== "production" ? PropTypes$1.timeoutsShape : {};
      if (!props.addEndListener) pt = pt.isRequired;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return pt.apply(void 0, [props].concat(args));
    },

    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. **Note:** Timeouts are still used as a fallback if provided.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: PropTypes$$1.func,

    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: PropTypes$$1.func,

    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes$$1.func,

    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: PropTypes$$1.func,

    /**
     * Callback fired before the "exiting" status is applied.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: PropTypes$$1.func,

    /**
     * Callback fired after the "exiting" status is applied.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: PropTypes$$1.func,

    /**
     * Callback fired after the "exited" status is applied.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: PropTypes$$1.func // Name the function so it is clearer in the documentation

  } : {};

  function noop() {}

  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
  };
  Transition.UNMOUNTED = 0;
  Transition.EXITED = 1;
  Transition.ENTERING = 2;
  Transition.ENTERED = 3;
  Transition.EXITING = 4;

  var _default =
  /*#__PURE__*/
  (0, reactLifecyclesCompat_es.polyfill)(Transition);

  exports.default = _default;
  });

  var Transition = unwrapExports(Transition_1);
  var Transition_2 = Transition_1.EXITING;
  var Transition_3 = Transition_1.ENTERED;
  var Transition_4 = Transition_1.ENTERING;
  var Transition_5 = Transition_1.EXITED;
  var Transition_6 = Transition_1.UNMOUNTED;

  function create$2() {
    var Portal =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Portal, _Component);

      function Portal() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          node: null
        };
        return _this;
      }

      var _proto = Portal.prototype;

      _proto.componentDidMount = function componentDidMount() {
        var node = document.createElement(this.props.type);
        document.body.appendChild(node);
        this.setState({
          node: node
        });
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        document.body.removeChild(this.state.node);
      };

      _proto.render = function render() {
        return this.state.node ? reactDom.createPortal(this.props.children, this.state.node) : null;
      };

      return Portal;
    }(React.Component);

    Portal.propTypes = {
      type: PropTypes.string,
      children: PropTypes.node
    };
    Portal.defaultProps = {
      type: 'sui-portal'
    };
    return Portal;
  }

  var Portal = /*#__PURE__*/
  create$2();

  var ModalContext = /*#__PURE__*/
  React.createContext();

  function createModalComponent() {
    var createAriaHider = function createAriaHider(dialogNode) {
      var originalValues = [];
      var rootNodes = [];
      Array.prototype.forEach.call(document.querySelectorAll('body > *'), function (node) {
        if (node === dialogNode.parentNode) {
          return;
        }

        var attr = node.getAttribute('aria-hidden');
        var alreadyHidden = attr !== null && attr !== 'false';

        if (alreadyHidden) {
          return;
        }

        originalValues.push(attr);
        rootNodes.push(node);
        node.setAttribute('aria-hidden', 'true');
      });
      return function () {
        rootNodes.forEach(function (node, index) {
          var originalValue = originalValues[index];

          if (originalValue === null) {
            node.removeAttribute('aria-hidden');
          } else {
            node.setAttribute('aria-hidden', originalValue);
          }
        });
      };
    };

    var cx = function cx() {
      for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
        classNames[_key] = arguments[_key];
      }

      return classNames.filter(Boolean).join(' ');
    };

    var ModalComponent =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(ModalComponent, _Component);

      function ModalComponent() {
        var _this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.contentRef = React__default.createRef();
        _this.trap = null;
        _this.disposeAriaHider = null;

        _this.handleDialogRef = function (dialogNode) {
          if (dialogNode) {
            _this.disposeAriaHider = createAriaHider(dialogNode);
          } else {
            _this.disposeAriaHider();
          }
        };

        _this.onFocusLockActivation = function () {
          var initialFocusRef = _this.props.initialFocusRef;

          if (initialFocusRef && initialFocusRef.current) {
            initialFocusRef.current.focus();
          }
        };

        return _this;
      }

      var _proto = ModalComponent.prototype;

      _proto.render = function render() {
        var _this2 = this;

        var _this$props = this.props,
            className = _this$props.className,
            forwardedRef = _this$props.forwardedRef,
            as = _this$props.as,
            theme = _this$props.theme,
            opened = _this$props.opened,
            onClose = _this$props.onClose,
            children = _this$props.children,
            persistent = _this$props.persistent,
            onClick = _this$props.onClick,
            onKeyDown = _this$props.onKeyDown,
            initialFocusRef = _this$props.initialFocusRef,
            props = _objectWithoutPropertiesLoose(_this$props, ["className", "forwardedRef", "as", "theme", "opened", "onClose", "children", "persistent", "onClick", "onKeyDown", "initialFocusRef"]);

        var timeout = modalTransitionDuration({
          theme: theme || {}
        });
        return React__default.createElement(Transition, {
          timeout: timeout,
          in: opened
        }, function (status) {
          if (status === 'exited') return null;
          return React__default.createElement(Portal, null, React__default.createElement(FocusLock, {
            returnFocus: true,
            onActivation: _this2.onFocusLockActivation
          }, React__default.createElement(RemoveScroll, {
            forwardProps: true
          }, React__default.createElement("div", _extends({
            className: cx('sui-modal', "sui-modal-transition-" + status, className),
            ref: _this2.handleDialogRef,
            onClick: wrapEvent(onClick, function (event) {
              event.stopPropagation();
              onClose();
            }),
            onKeyDown: wrapEvent(onKeyDown, function (event) {
              if (event.key === 'Escape') {
                event.stopPropagation();
                onClose();
              }
            })
          }, props), React__default.createElement(ModalContext.Provider, {
            value: {
              contentRef: _this2.contentRef,
              onClose: onClose
            }
          }, children)))));
        });
      };

      return ModalComponent;
    }(React.Component);

    var ModalComponentWithTheme = styled.withTheme(ModalComponent);
    return ModalComponentWithTheme;
  }

  var Modal =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal',
      InnerComponent: createModalComponent(),
      style: function style(p) {
        return styled.css(["position:fixed;top:0;right:0;bottom:0;left:0;z-index:", ";visibility:visible;overflow-x:hidden;overflow-y:auto;opacity:0;outline:0;background-color:", ";", ";&.sui-modal-transition-entering{opacity:0;}&.sui-modal-transition-entered{opacity:1;}&.sui-modal-transition-exiting{opacity:0;}"], zIndexModal(p), modalBackdropBg(p), transition("opacity " + modalTransitionDuration(p) + "ms ease-in-out")(p));
      },
      propTypes: {
        children: PropTypes.node,
        opened: PropTypes.bool,
        onClose: PropTypes.func,
        initialFocusRef: PropTypes.object
      },
      defaultProps: {
        persistent: true
      }
    };
  });

  var ModalBody =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal-body',
      style: function style(p) {
        return styled.css(["position:relative;flex:1 1 auto;padding:", ";"], modalInnerPadding(p));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var ModalContent =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal-content',
      render: function render(_ref) {
        var Component = _ref.Component,
            _ref2 = _ref.ref,
            onClick = _ref.onClick,
            props = _objectWithoutPropertiesLoose(_ref, ["Component", "ref", "onClick"]);

        return React__default.createElement(ModalContext.Consumer, null, function (modalContext) {
          return React__default.createElement(Component, _extends({
            tabIndex: "-1",
            ref: function ref(node) {
              if (modalContext) modalContext.contentRef.current = node;
              if (_ref2) _ref2(node);
            },
            onClick: wrapEvent(onClick, stopPropagation)
          }, props));
        });
      },
      style: function style(p) {
        return styled.css(["position:relative;display:flex;flex-direction:column;width:100%;pointer-events:auto;background-color:", ";background-clip:padding-box;border-style:solid;border-width:", ";border-color:", ";border-radius:", ";", ";outline:0;", ";"], modalContentBg(p), modalContentBorderWidth(p), modalContentBorderColor(p), modalContentBorderRadius(p), modalContentBoxShadowXs(p), up('sm', modalContentBoxShadowSmUp(p)));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var ModalCloseButton =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal-close-button',
      defaultComponent: 'button',
      render: function render(_ref) {
        var Component = _ref.Component,
            onClick = _ref.onClick,
            ref = _ref.ref,
            props = _objectWithoutPropertiesLoose(_ref, ["Component", "onClick", "ref"]);

        return React__default.createElement(ModalContext.Consumer, null, function (modalContext) {
          return React__default.createElement(Component, _extends({
            ref: ref,
            onClick: wrapEvent(onClick, function () {
              if (modalContext) {
                modalContext.onClose();
              }
            })
          }, props), React__default.createElement("span", {
            "aria-hidden": "true"
          }, "\xD7"));
        });
      },
      style: function style(p) {
        return styled.css(["position:absolute;cursor:pointer;top:0.2rem;right:0.2rem;padding:0.3rem 0.8rem;margin:0;background-color:transparent;appearance:none;border:0;font-size:1.5rem;font-weight:700;line-height:1;border-radius:", ";opacity:0.5;", ";&:focus{opacity:1;", ";}&:hover{opacity:1;}"], borderRadius(p), transitionBase(p), baseFocus(primary(p))(p));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var ModalDialog =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal-dialog',
      render: function render(_ref) {
        var Component = _ref.Component,
            props = _objectWithoutPropertiesLoose(_ref, ["Component"]);

        return React__default.createElement(Component, _extends({
          role: "dialog",
          "aria-modal": "true"
        }, props));
      },
      style: function style(p) {
        var margin = modalDialogMargin(p);
        var upSmMargin = modalDialogMarginYSmUp(p);
        return styled.css(["position:relative;width:auto;margin:", ";pointer-events:none;display:flex;align-items:center;min-height:calc(100% - ", ");", ";"], margin, calc(margin, function (x) {
          return x * 2;
        }), up('sm', styled.css(["max-width:500px;margin:", " auto;min-height:calc(100% - ", ");"], upSmMargin, calc(upSmMargin, function (x) {
          return x * 2;
        }))));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var ModalFooter =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal-footer',
      style: function style(p) {
        return styled.css(["display:flex;align-items:center;justify-content:flex-end;padding:", ";border-top-width:", ";border-top-style:solid;border-top-color:", ";>:not(:first-child){margin-left:0.25rem;}>:not(:last-child){margin-right:0.25rem;}"], modalInnerPadding(p), modalFooterBorderWidth(p), modalFooterBorderColor(p));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var ModalHeader =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'modal-header',
      style: function style(p) {
        return styled.css(["display:flex;align-items:flex-start;justify-content:space-between;padding:", ";border-bottom-style:solid;border-bottom-width:", ";border-bottom-color:", ";border-top-left-radius:", ";border-top-right-radius:", ";"], modalInnerPadding(p), modalHeaderBorderWidth(p), modalHeaderBorderColor(p), modalContentBorderRadius(p), modalContentBorderRadius(p));
      },
      propTypes: {
        children: PropTypes.node
      }
    };
  });

  var sizeStyle$2 = {
    sm:
    /*#__PURE__*/
    styled.css([".sui-radio-content{width:0.875rem;height:0.875rem;}.sui-radio-circle{width:8px;height:8px;}"]),
    md:
    /*#__PURE__*/
    styled.css([".sui-radio-content{width:1rem;height:1rem;}.sui-radio-circle{width:10px;height:10px;}"]),
    lg:
    /*#__PURE__*/
    styled.css([".sui-radio-content{width:1.25rem;height:1.25rem;}.sui-radio-circle{width:14px;height:14px;}"])
  };

  var validStyle$2 = function validStyle(p$$1) {
    var valid = p$$1.valid;
    if (valid !== true && valid !== false) return null;
    var color$$1 = valid ? success(p$$1) : danger(p$$1);
    return styled.css(["input + .sui-radio-content,input:checked + .sui-radio-content{border-color:", ";}input:checked + .sui-radio-content .sui-radio-circle{background-color:", ";}input:focus + .sui-radio-content{border-color:", ";", "}"], color$$1, color$$1, color$$1, controlFocus(color$$1)(p$$1));
  };

  var controlStyle$2 = function controlStyle(p$$1) {
    return styled.css(["input:focus + .sui-radio-content{", "}", ";"], controlFocus(primary(p$$1))(p$$1), validStyle$2(p$$1));
  };

  var containerSystem$1 =
  /*#__PURE__*/
  compose(basics, dimensions, space, flexboxes, positions);
  var contentSystem$1 =
  /*#__PURE__*/
  compose(dimensions, backgrounds, borders);
  var system$2 =
  /*#__PURE__*/
  compose(containerSystem$1, contentSystem$1);
  var Radio =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'radio',
      system: system$2,
      applySystem: null,
      render: function render(_ref) {
        var Component = _ref.Component,
            ref = _ref.ref,
            className = _ref.className,
            size = _ref.size,
            control = _ref.control,
            valid = _ref.valid,
            props = _objectWithoutPropertiesLoose(_ref, ["Component", "ref", "className", "size", "control", "valid"]);

        return React__default.createElement(SwitchState, props, function (_ref2) {
          var input = _ref2.input;
          return React__default.createElement(Component, {
            className: className
          }, React__default.createElement("input", _extends({
            ref: ref,
            type: "radio"
          }, input)), React__default.createElement("div", {
            className: "sui-radio-content"
          }, React__default.createElement("div", {
            className: "sui-radio-circle"
          })));
        });
      },
      style: function style$$1(p$$1) {
        return styled.css(["display:inline-flex;align-items:center;justify-content:center;position:relative;width:1.5rem;height:1.5rem;position:relative;.sui-radio-content{display:flex;flex-shrink:0;align-items:center;justify-content:center;border-radius:50%;background-color:", ";border-width:", ";border-style:solid;border-color:", ";", ";}input:checked + .sui-radio-content{border-color:", ";.sui-radio-circle{transform:scale(1);}}input:focus + .sui-radio-content{", ";}input:disabled + .sui-radio-content{background-color:", ";}.sui-radio-circle{", ";border-radius:50%;background-color:", ";transform:scale(0);}", ";", ";.sui-radio-content{", ";}", ";"], inputBgColor(p$$1), inputBorderWidth(p$$1), inputBorderColor(p$$1), transitionBase(p$$1), primary(p$$1), baseFocus(primary(p$$1))(p$$1), inputDisabledBgColor(p$$1), transitionBase(p$$1), primary(p$$1), p$$1.size && sizeStyle$2[p$$1.size], containerSystem$1.props, contentSystem$1.props, p$$1.control && controlStyle$2(p$$1));
      },
      propTypes: {
        control: PropTypes.bool,
        checked: PropTypes.bool,
        disabled: PropTypes.bool,
        onChange: PropTypes.func,
        size: PropTypes.oneOf(['sm', 'md', 'lg']),
        valid: PropTypes.bool,
        value: PropTypes.string
      },
      defaultProps: {
        size: 'md'
      }
    };
  });

  function create$3() {
    var RadioGroup =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(RadioGroup, _React$Component);

      function RadioGroup() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.controls = [];
        return _this;
      }

      var _proto = RadioGroup.prototype;

      _proto.getChildContext = function getChildContext() {
        return {
          suiGroup: this
        };
      };

      _proto.register = function register(control) {
        this.controls.push(control);
      };

      _proto.unregister = function unregister(control) {
        var index = this.controls.indexOf(control);
        if (index !== -1) this.controls.splice(index, 1);
      };

      _proto.notify = function notify(event) {
        this.controls.forEach(function (control) {
          if (control.props.checked === undefined && control.props.name === event.target.name && control.props.value !== event.target.value) {
            control.updateState({
              checked: false
            });
          }
        });
      };

      _proto.render = function render() {
        return this.props.children;
      };

      return RadioGroup;
    }(React__default.Component);

    RadioGroup.propTypes = {
      children: PropTypes.node
    };
    RadioGroup.childContextTypes = {
      suiGroup: PropTypes.object
    };
    return RadioGroup;
  }

  var RadioGroup = /*#__PURE__*/
  create$3();

  var Row =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'row',
      omitProps: ['gutter'],
      style: function style(p) {
        var _p$gutter = p.gutter,
            rawGutter = _p$gutter === void 0 ? gridGutter(p) : _p$gutter;
        var gutter = px(rawGutter);
        return styled.css(["box-sizing:border-box;flex-grow:1;flex-wrap:wrap;display:flex;margin-left:-", ";margin-right:-", ";"], gutter, gutter);
      },
      propTypes: {
        children: PropTypes.node,
        gutter: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
      }
    };
  });

  var sizeStyle$3 = {
    sm: function sm(p) {
      return styled.css(["select{padding:", " ", ";font-size:", ";line-height:", ";border-radius:", ";", ";}.sui-select-arrow{right:0.35rem;width:0.525rem;}"], inputPaddingYSm(p), inputPaddingXSm(p), fontSizeSm(p), inputLineHeightSm(p), borderRadiusSm(p), p.arrow && !p.multiple && 'padding-right: 1.225rem;');
    },
    md: function md(p) {
      return styled.css(["select{padding:", " ", ";font-size:", ";line-height:", ";", ";border-radius:", ";}.sui-select-arrow{right:0.5rem;width:0.6rem;}"], inputPaddingY(p), inputPaddingX(p), fontSizeBase(p), inputLineHeight(p), p.arrow && !p.multiple && 'padding-right: 1.6rem;', borderRadius(p));
    },
    lg: function lg(p) {
      return styled.css(["select{padding:", " ", ";font-size:", ";line-height:", ";border-radius:", ";", ";}.sui-select-arrow{right:0.625rem;width:0.75rem;}"], inputPaddingYLg(p), inputPaddingXLg(p), fontSizeLg(p), inputLineHeightLg(p), borderRadiusLg(p), p.arrow && !p.multiple && 'padding-right: 2rem;');
    }
  };

  var validStyle$3 = function validStyle(p) {
    var valid = p.valid;
    if (valid !== true && valid !== false) return null;
    var color = valid ? success(p) : danger(p);
    return styled.css(["select{border-color:", ";&:focus{border-color:", ";", "}}"], color, color, controlFocus(color)(p));
  };

  var controlStyle$3 = function controlStyle(p) {
    return styled.css(["&,select{display:block;width:100%;}select:focus{", ";}", ";"], controlFocus(primary(p))(p), validStyle$3(p));
  };

  var Arrow = function Arrow() {
    return React__default.createElement("svg", {
      className: "sui-select-arrow",
      viewBox: "0 0 10 5"
    }, React__default.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("path", {
      d: "M17 14H-7v-24h24"
    }), React__default.createElement("path", {
      fill: "currentColor",
      opacity: 0.5,
      d: "M0 0l5 5 5-5"
    })));
  };

  var Select =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'select',
      render: function render(_ref) {
        var Component = _ref.Component,
            arrow = _ref.arrow,
            control = _ref.control,
            className = _ref.className,
            size = _ref.size,
            valid = _ref.valid,
            children = _ref.children,
            props = _objectWithoutPropertiesLoose(_ref, ["Component", "arrow", "control", "className", "size", "valid", "children"]);

        return React__default.createElement(Component, {
          className: className
        }, arrow && !props.multiple ? React__default.createElement(Arrow, null) : null, React__default.createElement("select", props, children));
      },
      style: function style(p) {
        return styled.css(["display:inline-block;position:relative;select{appearance:none;-webkit-appearance:none;-moz-appearance:none;-webkit-border-radius:0;display:inline-block;border-width:", ";border-color:", ";border-style:solid;line-height:", ";", ";color:", ";&:focus{", ";}&:disabled{background-color:", ";color:", ";}}.sui-select-arrow{position:absolute;top:50%;pointer-events:none;}", ";", ";"], inputBorderWidth(p), inputBorderColor(p), inputLineHeight(p), transitionBase(p), inputTextColor(p), baseFocus(primary(p))(p), inputDisabledBgColor(p), inputDisabledText(p), p.size && sizeStyle$3[p.size] && sizeStyle$3[p.size](p), p.control && controlStyle$3(p));
      },
      propTypes: {
        arrow: PropTypes.bool,
        control: PropTypes.bool,
        options: PropTypes.array,
        size: PropTypes.oneOf(['sm', 'md', 'lg']),
        valid: PropTypes.bool,
        children: PropTypes.node
      },
      defaultProps: {
        arrow: true,
        size: 'md'
      }
    };
  });

  var Switch =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'switch',
      system: system,
      applySystem: null,
      render: function render(_ref) {
        var Component = _ref.Component,
            ref = _ref.ref,
            className = _ref.className,
            _ref$onLabel = _ref.onLabel,
            onLabel = _ref$onLabel === void 0 ? 'ON' : _ref$onLabel,
            _ref$offLabel = _ref.offLabel,
            offLabel = _ref$offLabel === void 0 ? 'OFF' : _ref$offLabel,
            labeled = _ref.labeled,
            props = _objectWithoutPropertiesLoose(_ref, ["Component", "ref", "className", "onLabel", "offLabel", "labeled"]);

        return React__default.createElement(SwitchState, props, function (_ref2) {
          var input = _ref2.input;
          return React__default.createElement(Component, {
            className: className
          }, React__default.createElement("input", _extends({
            ref: ref,
            type: "checkbox"
          }, input)), React__default.createElement("div", {
            className: "sui-switch-wrapper"
          }, React__default.createElement("div", {
            className: "sui-switch-content"
          }, React__default.createElement("span", {
            className: "sui-switch-label sui-switch-label-on"
          }, labeled ? onLabel : ''), React__default.createElement("div", {
            className: "sui-switch-ball"
          }), React__default.createElement("span", {
            className: "sui-switch-label sui-switch-label-off"
          }, labeled ? offLabel : ''))));
        });
      },
      style: function style$$1(p$$1) {
        return styled.css(["display:inline-block;position:relative;width:50px;height:24px;.sui-switch-wrapper{width:50px;height:24px;border-radius:34px;background-color:", ";overflow:hidden;cursor:pointer;border-width:", ";border-color:", ";border-style:solid;font-size:9px;font-weight:800;", ";}input:focused + .sui-switch-wrapper{", ";}input:checked + .sui-switch-wrapper{background-color:", ";border-color:transparent;.sui-switch-content{transform:translateX(0);}.sui-switch-ball{background-color:", ";}}input:disabled + .sui-switch-wrapper{opacity:0.5;}.sui-switch-ball{flex-shrink:0;background-color:", ";border-radius:50%;width:18px;height:18px;", ";}.sui-switch-content{display:flex;align-items:center;height:22px;transform:translateX(-25px);", ";}.sui-switch-label{flex-shrink:0;width:27px;text-align:center;user-select:none;&.sui-switch-label-on{color:", ";}&.sui-switch-label-off{color:", ";}}.sui-switch-wrapper{", ";}"], gray300(p$$1), inputBorderWidth(p$$1), inputBorderColor(p$$1), transitionBase(p$$1), baseFocus(primary(p$$1))(p$$1), primaryLight(p$$1), primary(p$$1), gray500(p$$1), transitionBase(p$$1), transitionBase(p$$1), primary(p$$1), gray900(p$$1), system.props);
      },
      propTypes: {
        checked: PropTypes.bool,
        disabled: PropTypes.bool,
        labeled: PropTypes.bool,
        onLabel: PropTypes.string,
        offLabel: PropTypes.string,
        onChange: PropTypes.func
      }
    };
  });

  function createTextarea() {
    var Textarea = Input.withComponent('textarea');
    Textarea.propTypes = Input.propTypes;
    return Textarea;
  }

  var Textarea = /*#__PURE__*/
  createTextarea();

  function create$4() {
    var Toggler =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Toggler, _Component);

      function Toggler() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          toggled: _this.props.defaultToggled
        };

        _this.onToggle = function (value) {
          _this.setState(function (previousState) {
            return {
              toggled: typeof value === 'boolean' ? value : !previousState.toggled
            };
          }, function () {
            if (_this.props.onToggle) {
              _this.props.onToggle(_this.state.toggled);
            }
          });
        };

        return _this;
      }

      var _proto = Toggler.prototype;

      _proto.render = function render() {
        return this.props.children({
          toggled: this.state.toggled,
          onToggle: this.onToggle
        });
      };

      return Toggler;
    }(React.Component);

    Toggler.propTypes = {
      children: PropTypes.func.isRequired,
      defaultToggled: PropTypes.bool,
      onToggle: PropTypes.func
    };
    Toggler.defaultProps = {
      defaultToggled: false
    };
    return Toggler;
  }

  var Toggler = /*#__PURE__*/
  create$4();

  var variantTags = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    'display-1': 'h1',
    'display-2': 'h2',
    'display-3': 'h3',
    'display-4': 'h4'
  };

  var commonHeadingStyle = function commonHeadingStyle(p) {
    var fontFamily$$1 = headingsFontFamily(p);
    return styled.css(["margin-top:0;margin-bottom:", ";font-weight:", ";line-height:", ";color:", ";", ";"], headingsMarginBottom(p), headingsFontWeight(p), headingsLineHeight(p), headingsColor(p), fontFamily$$1 && "font-family: " + fontFamily$$1);
  };

  var variantStyle = {
    h1: function h1(p) {
      return styled.css(["", ";font-size:", ";"], commonHeadingStyle(p), h1FontSize(p));
    },
    h2: function h2(p) {
      return styled.css(["", ";font-size:", ";"], commonHeadingStyle(p), h2FontSize(p));
    },
    h3: function h3(p) {
      return styled.css(["", ";font-size:", ";"], commonHeadingStyle(p), h3FontSize(p));
    },
    h4: function h4(p) {
      return styled.css(["", ";font-size:", ";"], commonHeadingStyle(p), h4FontSize(p));
    },
    h5: function h5(p) {
      return styled.css(["", ";font-size:", ";"], commonHeadingStyle(p), h5FontSize(p));
    },
    h6: function h6(p) {
      return styled.css(["", ";font-size:", ";"], commonHeadingStyle(p), h6FontSize(p));
    },
    'display-1': function display1(p) {
      return styled.css(["", ";font-size:", ";font-weight:", ";line-height:", ";"], commonHeadingStyle(p), display1Size(p), display1Weight(p), displayLineHeight(p));
    },
    'display-2': function display2(p) {
      return styled.css(["", ";font-size:", ";font-weight:", ";line-height:", ";"], commonHeadingStyle(p), display2Size(p), display2Weight(p), displayLineHeight(p));
    },
    'display-3': function display3(p) {
      return styled.css(["", ";font-size:", ";font-weight:", ";line-height:", ";"], commonHeadingStyle(p), display3Size(p), display3Weight(p), displayLineHeight(p));
    },
    'display-4': function display4(p) {
      return styled.css(["", ";font-size:", ";font-weight:", ";line-height:", ";"], commonHeadingStyle(p), display4Size(p), display4Weight(p), displayLineHeight(p));
    }
  };
  var Typography =
  /*#__PURE__*/
  createComponent(function () {
    return {
      name: 'typo',
      defaultComponent: null,
      render: function render(_ref) {
        var className = _ref.className,
            BaseComponent = _ref.Component,
            variant = _ref.variant,
            props = _objectWithoutPropertiesLoose(_ref, ["className", "Component", "variant"]);

        var Component = BaseComponent || variantTags[variant] || 'span';
        return React__default.createElement(Component, _extends({
          className: className
        }, props));
      },
      style: function style(p) {
        return styled.css(["", ";"], p.variant && variantStyle[p.variant] && variantStyle[p.variant](p));
      },
      propTypes: {
        children: PropTypes.node,
        variant: PropTypes.oneOf(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'display-1', 'display-2', 'display-3', 'display-4'])
      }
    };
  });

  var theme = /*#__PURE__*/
  definitionsToTheme(theming);

  Object.keys(styled).forEach(function (key) { exports[key] = styled[key]; });
  exports.styled = styled__default;
  exports.Alert = Alert;
  exports.Box = Box;
  exports.Breakpoint = Breakpoint;
  exports.Button = Button;
  exports.Checkbox = Checkbox;
  exports.Col = Col;
  exports.ControlFeedback = ControlFeedback;
  exports.FormCheck = FormCheck;
  exports.FormCheckLabel = FormCheckLabel;
  exports.FormGroup = FormGroup;
  exports.Normalize = Normalize;
  exports.Grid = Grid;
  exports.Input = Input;
  exports.Label = Label;
  exports.Modal = Modal;
  exports.ModalBody = ModalBody;
  exports.ModalContent = ModalContent;
  exports.ModalContext = ModalContext;
  exports.ModalCloseButton = ModalCloseButton;
  exports.ModalDialog = ModalDialog;
  exports.ModalFooter = ModalFooter;
  exports.ModalHeader = ModalHeader;
  exports.Portal = Portal;
  exports.Radio = Radio;
  exports.RadioGroup = RadioGroup;
  exports.Row = Row;
  exports.Select = Select;
  exports.Switch = Switch;
  exports.SwitchState = SwitchState;
  exports.Textarea = Textarea;
  exports.Toggler = Toggler;
  exports.Transition = Transition;
  exports.Typography = Typography;
  exports.theme = theme;
  exports.wrapEvent = wrapEvent;
  exports.stopPropagation = stopPropagation;
  exports.mediaMinWidth = mediaMinWidth;
  exports.mediaMaxWidth = mediaMaxWidth;
  exports.mediaBetweenWidth = mediaBetweenWidth;
  exports.getTheme = getTheme;
  exports.thd = thd;
  exports.th = th;
  exports.mixin = mixin;
  exports.definitionsToTheme = definitionsToTheme;
  exports.is = is;
  exports.num = num;
  exports.func = func;
  exports.get = get;
  exports.cascade = cascade;
  exports.omit = omit;
  exports.unit = unit;
  exports.px = px;
  exports.calc = calc;
  exports.alertPaddingY = alertPaddingY;
  exports.alertPaddingX = alertPaddingX;
  exports.alertMarginBottom = alertMarginBottom;
  exports.alertColorLevel = alertColorLevel;
  exports.alertBgLevel = alertBgLevel;
  exports.alertBorderLevel = alertBorderLevel;
  exports.alertVariant = alertVariant;
  exports.borderRadius = borderRadius;
  exports.borderRadiusSm = borderRadiusSm;
  exports.borderRadiusLg = borderRadiusLg;
  exports.borderWidth = borderWidth;
  exports.btnPaddingY = btnPaddingY;
  exports.btnPaddingX = btnPaddingX;
  exports.btnLineHeight = btnLineHeight;
  exports.btnPaddingYSm = btnPaddingYSm;
  exports.btnPaddingXSm = btnPaddingXSm;
  exports.btnLineHeightSm = btnLineHeightSm;
  exports.btnPaddingYLg = btnPaddingYLg;
  exports.btnPaddingXLg = btnPaddingXLg;
  exports.btnLineHeightLg = btnLineHeightLg;
  exports.btnBorderWidth = btnBorderWidth;
  exports.btnDisabledOpacity = btnDisabledOpacity;
  exports.btnVariant = btnVariant;
  exports.black = black;
  exports.white = white;
  exports.gray100 = gray100;
  exports.gray200 = gray200;
  exports.gray300 = gray300;
  exports.gray400 = gray400;
  exports.gray500 = gray500;
  exports.gray600 = gray600;
  exports.gray700 = gray700;
  exports.gray800 = gray800;
  exports.gray900 = gray900;
  exports.blue = blue;
  exports.indigo = indigo;
  exports.purple = purple;
  exports.pink = pink;
  exports.red = red;
  exports.brick = brick;
  exports.orange = orange;
  exports.yellow = yellow;
  exports.green = green;
  exports.teal = teal;
  exports.cyan = cyan;
  exports.primary = primary;
  exports.secondary = secondary;
  exports.success = success;
  exports.info = info;
  exports.warning = warning;
  exports.danger = danger;
  exports.light = light;
  exports.dark = dark;
  exports.primaryLight = primaryLight;
  exports.secondaryLight = secondaryLight;
  exports.colorVariants = colorVariants;
  exports.colors = colors;
  exports.colorInterval = colorInterval;
  exports.colorVariant = colorVariant;
  exports.colorLevel = colorLevel;
  exports.yiqContrastedThreshold = yiqContrastedThreshold;
  exports.yikTextDark = yikTextDark;
  exports.yikTextLight = yikTextLight;
  exports.colorYik = colorYik;
  exports.baseFocus = baseFocus;
  exports.controlFocus = controlFocus;
  exports.gridColumns = gridColumns;
  exports.gridGutter = gridGutter;
  exports.gridMaxWidths = gridMaxWidths;
  exports.headingsMarginBottom = headingsMarginBottom;
  exports.headingsFontFamily = headingsFontFamily;
  exports.headingsFontWeight = headingsFontWeight;
  exports.headingsLineHeight = headingsLineHeight;
  exports.headingsColor = headingsColor;
  exports.h1FontSize = h1FontSize;
  exports.h2FontSize = h2FontSize;
  exports.h3FontSize = h3FontSize;
  exports.h4FontSize = h4FontSize;
  exports.h5FontSize = h5FontSize;
  exports.h6FontSize = h6FontSize;
  exports.display1Size = display1Size;
  exports.display2Size = display2Size;
  exports.display3Size = display3Size;
  exports.display4Size = display4Size;
  exports.display1Weight = display1Weight;
  exports.display2Weight = display2Weight;
  exports.display3Weight = display3Weight;
  exports.display4Weight = display4Weight;
  exports.displayLineHeight = displayLineHeight;
  exports.inputBtnPaddingY = inputBtnPaddingY;
  exports.inputBtnPaddingX = inputBtnPaddingX;
  exports.inputBtnLineHeight = inputBtnLineHeight;
  exports.inputBtnPaddingYSm = inputBtnPaddingYSm;
  exports.inputBtnPaddingXSm = inputBtnPaddingXSm;
  exports.inputBtnLineHeightSm = inputBtnLineHeightSm;
  exports.inputBtnPaddingYLg = inputBtnPaddingYLg;
  exports.inputBtnPaddingXLg = inputBtnPaddingXLg;
  exports.inputBtnLineHeightLg = inputBtnLineHeightLg;
  exports.inputPaddingY = inputPaddingY;
  exports.inputPaddingX = inputPaddingX;
  exports.inputLineHeight = inputLineHeight;
  exports.inputPaddingYSm = inputPaddingYSm;
  exports.inputPaddingXSm = inputPaddingXSm;
  exports.inputLineHeightSm = inputLineHeightSm;
  exports.inputPaddingYLg = inputPaddingYLg;
  exports.inputPaddingXLg = inputPaddingXLg;
  exports.inputLineHeightLg = inputLineHeightLg;
  exports.inputBorderWidth = inputBorderWidth;
  exports.inputBorderColor = inputBorderColor;
  exports.inputBgColor = inputBgColor;
  exports.inputDisabledBgColor = inputDisabledBgColor;
  exports.inputDisabledText = inputDisabledText;
  exports.inputPlaceholderText = inputPlaceholderText;
  exports.inputTextColor = inputTextColor;
  exports.modalBackdropBg = modalBackdropBg;
  exports.modalTransitionDuration = modalTransitionDuration;
  exports.modalInnerPadding = modalInnerPadding;
  exports.modalDialogMargin = modalDialogMargin;
  exports.modalDialogMarginYSmUp = modalDialogMarginYSmUp;
  exports.modalContentBg = modalContentBg;
  exports.modalContentBorderWidth = modalContentBorderWidth;
  exports.modalContentBorderColor = modalContentBorderColor;
  exports.modalContentBorderRadius = modalContentBorderRadius;
  exports.modalContentBoxShadowXs = modalContentBoxShadowXs;
  exports.modalContentBoxShadowSmUp = modalContentBoxShadowSmUp;
  exports.modalHeaderBorderColor = modalHeaderBorderColor;
  exports.modalFooterBorderColor = modalFooterBorderColor;
  exports.modalHeaderBorderWidth = modalHeaderBorderWidth;
  exports.modalFooterBorderWidth = modalFooterBorderWidth;
  exports.breakpoints = breakpoints;
  exports.up = up;
  exports.down = down;
  exports.between = between;
  exports.spaces = spaces;
  exports.transitionEnabled = transitionEnabled;
  exports.transitionDuration = transitionDuration;
  exports.transitionEasingFunc = transitionEasingFunc;
  exports.transition = transition;
  exports.transitionBase = transitionBase;
  exports.fontSizes = fontSizes;
  exports.fontFamily = fontFamily;
  exports.fontSizeBase = fontSizeBase;
  exports.fontSizeSm = fontSizeSm;
  exports.fontSizeLg = fontSizeLg;
  exports.fontWeightLight = fontWeightLight;
  exports.fontWeightNormal = fontWeightNormal;
  exports.fontWeightBold = fontWeightBold;
  exports.lineHeightBase = lineHeightBase;
  exports.lineHeightSm = lineHeightSm;
  exports.lineHeightLg = lineHeightLg;
  exports.zIndexControl = zIndexControl;
  exports.zIndexInnerSwitch = zIndexInnerSwitch;
  exports.zIndexModal = zIndexModal;
  exports.zIndexModalBackdrop = zIndexModalBackdrop;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
